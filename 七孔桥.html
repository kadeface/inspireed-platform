<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã€Šå¼€å¹³é•¿å¸ˆé™„å±å°å­¦æŠ½è±¡æ•°å­¦å¯è§†åŒ–æ¢ç©¶ã€‹ - ä¸ƒæ¡¥é—®é¢˜ä¸æ¬§æ‹‰è·¯å¾„</title>
    <style>
        :root {
            --primary-background: #FFFFFF;
            --text-color: #000000;
            --border-color: #E0E0E0;
            --main-color: #FF6600;
            --main-color-light: #FF9933;
            --accent-color: #4CAF50;
            --error-color: #D32F2F;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--primary-background);
            color: var(--text-color);
            font-family: 'Microsoft YaHei', 'Arial', sans-serif;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 3px solid var(--main-color);
            margin-bottom: 30px;
        }

        h1 {
            color: var(--main-color);
            font-size: 28px;
            margin-bottom: 10px;
        }

        h2 {
            color: var(--text-color);
            font-size: 22px;
            font-weight: normal;
        }

        #visualization-area {
            display: flex;
            gap: 20px;
            min-height: 500px;
            margin-bottom: 30px;
        }

        .left-panel {
            flex: 0 0 45%;
            background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 100%);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            position: relative;
        }

        .right-panel {
            flex: 0 0 55%;
            background: #fafafa;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--main-color);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--main-color-light);
        }

        #bridge-canvas {
            width: 100%;
            height: 450px;
            cursor: crosshair;
            background-color: white;
            border-radius: 8px;
        }

        #graph-canvas {
            width: 100%;
            height: 450px;
            background-color: white;
            border-radius: 8px;
        }

        #control-panel {
            background: #f9f9f9;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-primary {
            background-color: var(--main-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--main-color-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 102, 0, 0.3);
        }

        .btn-success {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-success:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }

        .btn-secondary {
            background-color: #757575;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #616161;
        }

        #instructions {
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
        }

        .instruction-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--main-color);
            margin-bottom: 10px;
        }

        .instruction-content {
            line-height: 1.8;
            font-size: 15px;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
        }

        .feedback.success {
            background-color: rgba(76, 175, 80, 0.1);
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            display: block;
        }

        .feedback.error {
            background-color: rgba(211, 47, 47, 0.1);
            border: 2px solid var(--error-color);
            color: var(--error-color);
            display: block;
        }

        .feedback.info {
            background-color: rgba(255, 102, 0, 0.1);
            border: 2px solid var(--main-color);
            color: var(--main-color);
            display: block;
        }

        .stats-panel {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 102, 0, 0.05);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .stat-item {
            margin: 8px 0;
            font-size: 15px;
        }

        .stat-label {
            font-weight: bold;
            color: var(--main-color);
        }

        .degree-display {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .degree-item {
            margin: 5px 0;
            font-size: 14px;
        }

        .odd-degree {
            color: var(--error-color);
            font-weight: bold;
        }

        .even-degree {
            color: var(--accent-color);
        }
    </style>
</head>
<body>
    <header>
        <h1>ã€Šå¼€å¹³é•¿å¸ˆé™„å±å°å­¦æŠ½è±¡æ•°å­¦å¯è§†åŒ–æ¢ç©¶ã€‹</h1>
        <h2>ä¸ƒæ¡¥é—®é¢˜ä¸æ¬§æ‹‰è·¯å¾„</h2>
    </header>

    <div id="visualization-area">
        <div class="left-panel">
            <div class="panel-title">ğŸŒ‰ æƒ…å¢ƒäº¤äº’åŒºï¼šä¹¡æ‘å°æ¡¥åœ°å›¾</div>
            <canvas id="bridge-canvas"></canvas>
        </div>
        <div class="right-panel">
            <div class="panel-title">ğŸ“Š é€»è¾‘åŸç†åŒºï¼šå›¾è®ºæŠ½è±¡æ¨¡å‹</div>
            <canvas id="graph-canvas"></canvas>
            <div class="degree-display" id="degree-info"></div>
        </div>
    </div>

    <div id="control-panel">
        <div style="margin-bottom: 15px; padding: 15px; background: #f0f0f0; border-radius: 8px;">
            <label for="bridge-count" style="font-weight: bold; color: var(--main-color); margin-right: 10px;">é€‰æ‹©æ¡¥çš„æ•°é‡ï¼š</label>
            <select id="bridge-count" style="padding: 8px 15px; font-size: 16px; border: 2px solid var(--main-color); border-radius: 6px; cursor: pointer; background: white;" onchange="generateNewGraph()">
                <option value="3">3åº§æ¡¥</option>
                <option value="4">4åº§æ¡¥</option>
                <option value="5">5åº§æ¡¥</option>
                <option value="6" selected>6åº§æ¡¥ï¼ˆç»å…¸ä¸ƒæ¡¥é—®é¢˜ï¼‰</option>
                <option value="7">7åº§æ¡¥</option>
                <option value="8">8åº§æ¡¥</option>
                <option value="9">9åº§æ¡¥</option>
                <option value="10">10åº§æ¡¥</option>
            </select>
            <button class="btn-secondary" onclick="generateNewGraph()" style="margin-left: 10px; padding: 8px 15px;">ğŸ”„ é‡æ–°ç”Ÿæˆ</button>
        </div>
        <div class="button-group">
            <button class="btn-primary" onclick="startDrawing()">ğŸ–Šï¸ å¼€å§‹ç»˜åˆ¶è·¯å¾„</button>
            <button class="btn-success" onclick="validatePath()">âœ“ éªŒè¯è·¯å¾„</button>
            <button class="btn-secondary" onclick="resetCanvas()">â†» é‡ç½®</button>
            <button class="btn-primary" onclick="showHint()">ğŸ’¡ æ˜¾ç¤ºæç¤º</button>
            <button class="btn-success" onclick="showTheory()">ğŸ“š æŸ¥çœ‹åŸç†</button>
        </div>
        <div class="stats-panel">
            <div class="stat-item"><span class="stat-label">å½“å‰çŠ¶æ€ï¼š</span><span id="status">ç­‰å¾…å¼€å§‹</span></div>
            <div class="stat-item"><span class="stat-label">å·²èµ°è¿‡çš„æ¡¥ï¼š</span><span id="bridges-crossed">0 / 6</span></div>
            <div class="stat-item"><span class="stat-label">å½“å‰ä½ç½®ï¼š</span><span id="current-location">æœªå¼€å§‹</span></div>
        </div>
    </div>

    <div id="instructions">
        <div class="instruction-title">ğŸ“– æ“ä½œè¯´æ˜</div>
        <div class="instruction-content">
            <p><strong>æŒ‘æˆ˜ç›®æ ‡ï¼š</strong>ä½ èƒ½ä¸€æ¬¡ä¸é‡å¤åœ°èµ°éæ‰€æœ‰çš„6åº§å°æ¡¥å—ï¼Ÿï¼ˆæ¯åº§æ¡¥æœ€å¤šåªèƒ½èµ°ä¸€æ¬¡ï¼Œé™†åœ°ä¸Šå¯ä»¥é‡å¤èµ°ï¼‰</p>
            <br>
            <p><strong>æ“ä½œæ­¥éª¤ï¼š</strong></p>
            <p>1ï¸âƒ£ ç‚¹å‡»"å¼€å§‹ç»˜åˆ¶è·¯å¾„"æŒ‰é’®</p>
            <p>2ï¸âƒ£ åœ¨å·¦ä¾§åœ°å›¾ä¸Šç‚¹å‡»é€‰æ‹©èµ·ç‚¹ï¼ˆå‚æ‘/ä¸™æ‘/ä¹™æ‘/ç”²æ‘ï¼‰</p>
            <p>3ï¸âƒ£ ä¾æ¬¡ç‚¹å‡»ä½ æƒ³è¦ç»è¿‡çš„æ¡¥æ¢ï¼ˆé»„è‰²æ¡¥æ¢ï¼‰ï¼Œæ¯åº§æ¡¥åªèƒ½ç‚¹å‡»ä¸€æ¬¡</p>
            <p>4ï¸âƒ£ å°è¯•èµ°å®Œæ‰€æœ‰6åº§æ¡¥ï¼Œè§‚å¯Ÿå³ä¾§çš„å›¾è®ºæ¨¡å‹åŒæ­¥é«˜äº®</p>
            <p>5ï¸âƒ£ ç‚¹å‡»"éªŒè¯è·¯å¾„"æŸ¥çœ‹ä½ çš„è·¯å¾„æ˜¯å¦æœ‰æ•ˆ</p>
            <br>
            <p><strong>å­¦ä¹ é‡ç‚¹ï¼š</strong>è§‚å¯Ÿå³ä¾§"é€»è¾‘åŸç†åŒº"ä¸­æ¯ä¸ªæ‘åº„è¿æ¥çš„æ¡¥æ¢æ•°é‡ï¼ˆé¡¶ç‚¹åº¦æ•°ï¼‰ï¼Œæ€è€ƒè¿™ä¸èƒ½å¦ä¸€ç¬”ç”»å®Œæœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ</p>
        </div>
        <div class="feedback" id="feedback"></div>
    </div>

    <script>
        // ç”»å¸ƒåˆå§‹åŒ–
        const bridgeCanvas = document.getElementById('bridge-canvas');
        const bridgeCtx = bridgeCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            // ç¡®ä¿ç”»å¸ƒæœ‰è¶³å¤Ÿçš„å°ºå¯¸æ¥æ˜¾ç¤ºæ‰€æœ‰å†…å®¹
            const bridgeContainer = bridgeCanvas.parentElement;
            const graphContainer = graphCanvas.parentElement;
            
            // è®¾ç½®å®é™…åƒç´ å°ºå¯¸ï¼ˆè€ƒè™‘è®¾å¤‡åƒç´ æ¯”ï¼‰
            const dpr = window.devicePixelRatio || 1;
            // ç¡®ä¿æœ€å°å®½åº¦ï¼Œä»¥å®¹çº³æ‰€æœ‰åæ ‡ï¼ˆæœ€å¤§xåæ ‡æ˜¯450ï¼‰
            const bridgeWidth = Math.max(bridgeContainer.clientWidth || 500, 500);
            const bridgeHeight = 450; // å›ºå®šé«˜åº¦
            const graphWidth = Math.max(graphContainer.clientWidth || 500, 500);
            const graphHeight = 450; // å›ºå®šé«˜åº¦
            
            bridgeCanvas.width = bridgeWidth * dpr;
            bridgeCanvas.height = bridgeHeight * dpr;
            graphCanvas.width = graphWidth * dpr;
            graphCanvas.height = graphHeight * dpr;
            
            // è®¾ç½®CSSå°ºå¯¸
            bridgeCanvas.style.width = bridgeWidth + 'px';
            bridgeCanvas.style.height = bridgeHeight + 'px';
            graphCanvas.style.width = graphWidth + 'px';
            graphCanvas.style.height = graphHeight + 'px';
            
            // é‡ç½®å˜æ¢çŸ©é˜µå¹¶ç¼©æ”¾ä¸Šä¸‹æ–‡ä»¥é€‚åº”è®¾å¤‡åƒç´ æ¯”
            bridgeCtx.setTransform(1, 0, 0, 1, 0, 0);
            bridgeCtx.scale(dpr, dpr);
            graphCtx.setTransform(1, 0, 0, 1, 0, 0);
            graphCtx.scale(dpr, dpr);
            
            // é‡æ–°è®¡ç®—æ¡¥æ¢åæ ‡ï¼ˆé€‚åº”æ–°çš„ç”»å¸ƒå°ºå¯¸ï¼‰
            bridges.forEach(bridge => {
                const coords = calculateBridgeCoords(bridge);
                bridge.x1 = coords.x1;
                bridge.y1 = coords.y1;
                bridge.x2 = coords.x2;
                bridge.y2 = coords.y2;
                bridge.cx = coords.cx;
                bridge.cy = coords.cy;
            });
            
            drawBridgeMap();
            drawGraphModel();
        }
        
        // ç­‰å¾…DOMåŠ è½½å®Œæˆåå†åˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', resizeCanvas);
        } else {
            // ä½¿ç”¨setTimeoutç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
            setTimeout(resizeCanvas, 0);
        }

        // æ•°æ®ç»“æ„ï¼šæ‘åº„ï¼ˆé¡¶ç‚¹ï¼‰
        const villages = {
            'A': { name: 'å‚æ‘', x: 100, y: 150, graphX: 150, graphY: 100 },
            'B': { name: 'ä¸™æ‘', x: 350, y: 100, graphX: 450, graphY: 100 },
            'C': { name: 'ä¹™æ‘', x: 450, y: 280, graphX: 450, graphY: 300 },
            'D': { name: 'ç”²æ‘', x: 180, y: 350, graphX: 150, graphY: 300 }
        };

        // è®¡ç®—æ¡¥æ¢åæ ‡çš„å‡½æ•°
        function calculateBridgeCoords(bridge) {
            const fromVillage = villages[bridge.from];
            const toVillage = villages[bridge.to];
            
            // è®¡ç®—ä»æ‘åº„ä¸­å¿ƒåˆ°å¦ä¸€ä¸ªæ‘åº„ä¸­å¿ƒçš„æ–¹å‘
            const dx = toVillage.x - fromVillage.x;
            const dy = toVillage.y - fromVillage.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // æ‘åº„åŠå¾„
            const villageRadius = 12;
            
            // è®¡ç®—èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆä»æ‘åº„è¾¹ç¼˜å¼€å§‹ï¼‰
            const startX = fromVillage.x + (dx / distance) * villageRadius;
            const startY = fromVillage.y + (dy / distance) * villageRadius;
            const endX = toVillage.x - (dx / distance) * villageRadius;
            const endY = toVillage.y - (dy / distance) * villageRadius;
            
            // è®¡ç®—æ§åˆ¶ç‚¹ï¼ˆä½¿æ¡¥æ¢å‘ˆç°å¼¯æ›²æ•ˆæœï¼‰
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            
            // è®¡ç®—å‚ç›´æ–¹å‘ï¼ˆç”¨äºåç§»ï¼‰
            const perpendicularX = -dy / distance;
            const perpendicularY = dx / distance;
            
            // æ‰¾å‡ºè¿æ¥ç›¸åŒä¸¤ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰è¾¹
            const sameEdges = bridges.filter(b => 
                (b.from === bridge.from && b.to === bridge.to) ||
                (b.from === bridge.to && b.to === bridge.from)
            );
            sameEdges.sort((a, b) => a.id - b.id);
            
            // è®¡ç®—è¿™æ¡è¾¹åœ¨åŒå‘è¾¹ä¸­çš„ç´¢å¼•
            const edgeIndex = sameEdges.findIndex(b => b.id === bridge.id);
            const totalSameEdges = sameEdges.length;
            
            // æ ¹æ®ç´¢å¼•è®¡ç®—åç§»é‡ï¼ˆä½¿å¤šæ¡è¾¹åˆ†å¼€æ˜¾ç¤ºï¼‰
            // å¦‚æœåªæœ‰ä¸€æ¡è¾¹ï¼Œä½¿ç”¨è¾ƒå°çš„åç§»ï¼›å¦‚æœæœ‰å¤šæ¡è¾¹ï¼Œä½¿ç”¨è¾ƒå¤§çš„åç§»
            const baseOffset = totalSameEdges === 1 ? 20 : 30;
            const offsetDistance = (edgeIndex - (totalSameEdges - 1) / 2) * baseOffset;
            
            // æ ¹æ®æ¡¥çš„IDæ·»åŠ é¢å¤–çš„å˜åŒ–ï¼Œä½¿æ¯æ¡æ¡¥éƒ½æœ‰ç‹¬ç‰¹çš„å¼¯æ›²
            const variation = (bridge.id % 3 - 1) * 5; // -5, 0, 5çš„å¾ªç¯
            const finalOffset = offsetDistance + variation;
            
            const offsetX = perpendicularX * finalOffset;
            const offsetY = perpendicularY * finalOffset;
            
            return {
                x1: startX,
                y1: startY,
                x2: endX,
                y2: endY,
                cx: midX + offsetX,
                cy: midY + offsetY
            };
        }

        // æ•°æ®ç»“æ„ï¼šæ¡¥æ¢ï¼ˆè¾¹ï¼‰- æ”¹ä¸ºå¯å˜
        let bridges = [];

        // æ ¹æ®æ¡¥çš„æ•°é‡ç”Ÿæˆå›¾ç»“æ„
        function generateGraph(bridgeCount) {
            bridges = [];
            let bridgeId = 1;
            
            // é¢„å®šä¹‰çš„è¾¹æ¨¡æ¿ï¼ˆç¡®ä¿è¿é€šæ€§å’Œå¤šæ ·æ€§ï¼‰
            const edgeTemplates = [
                // åŸºç¡€è¿é€šè¾¹ï¼ˆå¿…é¡»åŒ…å«ï¼Œç¡®ä¿å›¾è¿é€šï¼‰
                { from: 'A', to: 'B' },  // æ¡¥1ï¼šè¿æ¥å‚æ‘å’Œä¸™æ‘
                { from: 'A', to: 'D' },  // æ¡¥2ï¼šè¿æ¥å‚æ‘å’Œç”²æ‘
                { from: 'B', to: 'C' },  // æ¡¥3ï¼šè¿æ¥ä¸™æ‘å’Œä¹™æ‘
                { from: 'D', to: 'C' },  // æ¡¥4ï¼šè¿æ¥ç”²æ‘å’Œä¹™æ‘
                
                // é¢å¤–çš„è¾¹ï¼ˆç”¨äºå¢åŠ æ¡¥çš„æ•°é‡ï¼‰
                { from: 'A', to: 'B' },  // æ¡¥5ï¼šé‡å¤è¾¹ï¼ˆA-Bï¼‰
                { from: 'D', to: 'C' },  // æ¡¥6ï¼šé‡å¤è¾¹ï¼ˆD-Cï¼‰
                { from: 'A', to: 'C' },  // æ¡¥7ï¼šå¯¹è§’çº¿ï¼ˆA-Cï¼‰
                { from: 'B', to: 'D' },  // æ¡¥8ï¼šå¯¹è§’çº¿ï¼ˆB-Dï¼‰
                { from: 'A', to: 'B' },  // æ¡¥9ï¼šé‡å¤è¾¹ï¼ˆA-Bï¼‰
                { from: 'D', to: 'C' },  // æ¡¥10ï¼šé‡å¤è¾¹ï¼ˆD-Cï¼‰
            ];
            
            // æ ¹æ®æ¡¥çš„æ•°é‡é€‰æ‹©è¾¹
            // ç¡®ä¿è‡³å°‘åŒ…å«å‰4æ¡è¾¹ä»¥ä¿è¯è¿é€šæ€§
            const minEdges = Math.min(4, bridgeCount);
            for (let i = 0; i < minEdges; i++) {
                const edge = edgeTemplates[i];
                bridges.push({
                    id: bridgeId++,
                    from: edge.from,
                    to: edge.to,
                    label: `æ¡¥${bridgeId - 1}`
                });
            }
            
            // å¦‚æœéœ€è¦çš„æ¡¥æ•°é‡è¶…è¿‡4ï¼Œæ·»åŠ é¢å¤–çš„è¾¹
            if (bridgeCount > 4) {
                for (let i = 4; i < bridgeCount && i < edgeTemplates.length; i++) {
                    const edge = edgeTemplates[i];
                    bridges.push({
                        id: bridgeId++,
                        from: edge.from,
                        to: edge.to,
                        label: `æ¡¥${bridgeId - 1}`
                    });
                }
            }
            
            // ä¸ºæ¯åº§æ¡¥è®¡ç®—åæ ‡
            bridges.forEach(bridge => {
                const coords = calculateBridgeCoords(bridge);
                bridge.x1 = coords.x1;
                bridge.y1 = coords.y1;
                bridge.x2 = coords.x2;
                bridge.y2 = coords.y2;
                bridge.cx = coords.cx;
                bridge.cy = coords.cy;
            });
            
            // æ›´æ–°UIæ˜¾ç¤º
            updateBridgeCountDisplay();
        }
        
        // æ›´æ–°æ¡¥æ•°é‡æ˜¾ç¤º
        function updateBridgeCountDisplay() {
            const bridgeCount = bridges.length;
            document.getElementById('bridges-crossed').textContent = `0 / ${bridgeCount}`;
            
            // æ›´æ–°è¯´æ˜æ–‡å­—
            const instructionContent = document.querySelector('.instruction-content');
            if (instructionContent) {
                const firstP = instructionContent.querySelector('p');
                if (firstP) {
                    firstP.innerHTML = `<strong>æŒ‘æˆ˜ç›®æ ‡ï¼š</strong>ä½ èƒ½ä¸€æ¬¡ä¸é‡å¤åœ°èµ°éæ‰€æœ‰çš„${bridgeCount}åº§å°æ¡¥å—ï¼Ÿï¼ˆæ¯åº§æ¡¥æœ€å¤šåªèƒ½èµ°ä¸€æ¬¡ï¼Œé™†åœ°ä¸Šå¯ä»¥é‡å¤èµ°ï¼‰`;
                }
                // æ›´æ–°ç¬¬4æ­¥è¯´æ˜
                const steps = instructionContent.querySelectorAll('p');
                if (steps.length >= 4) {
                    steps[3].innerHTML = `4ï¸âƒ£ å°è¯•èµ°å®Œæ‰€æœ‰${bridgeCount}åº§æ¡¥ï¼Œè§‚å¯Ÿå³ä¾§çš„å›¾è®ºæ¨¡å‹åŒæ­¥é«˜äº®`;
                }
            }
        }
        
        // ç”Ÿæˆæ–°å›¾çš„å‡½æ•°ï¼ˆä¾›UIè°ƒç”¨ï¼‰
        function generateNewGraph() {
            const bridgeCount = parseInt(document.getElementById('bridge-count').value);
            generateGraph(bridgeCount);
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.isDrawing = false;
            gameState.currentVillage = null;
            gameState.visitedBridges.clear();
            gameState.path = [];
            gameState.pathVertices = [];
            
            document.getElementById('status').textContent = 'ç­‰å¾…å¼€å§‹';
            document.getElementById('bridges-crossed').textContent = `0 / ${bridgeCount}`;
            document.getElementById('current-location').textContent = 'æœªå¼€å§‹';
            document.getElementById('feedback').className = 'feedback';
            document.getElementById('feedback').style.display = 'none';
            
            // é‡æ–°ç»˜åˆ¶
            drawBridgeMap();
            drawGraphModel();
            updateDegreeDisplay();
        }
        
        // åˆå§‹åŒ–ï¼šç”Ÿæˆ6åº§æ¡¥çš„å›¾
        generateGraph(6);

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            isDrawing: false,
            currentVillage: null,
            visitedBridges: new Set(),
            path: [],
            pathVertices: []
        };

        // ç»˜åˆ¶æ²³æµèƒŒæ™¯
        function drawRiver(ctx) {
            ctx.fillStyle = '#4A90E2';
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(50, 100);
            ctx.bezierCurveTo(200, 80, 350, 150, 500, 120);
            ctx.bezierCurveTo(520, 200, 480, 280, 500, 380);
            ctx.bezierCurveTo(400, 370, 300, 360, 200, 380);
            ctx.bezierCurveTo(150, 300, 100, 250, 80, 180);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        // ç»˜åˆ¶æ¡¥æ¢åœ°å›¾
        function drawBridgeMap() {
            bridgeCtx.clearRect(0, 0, bridgeCanvas.width, bridgeCanvas.height);
            
            // ç»˜åˆ¶æ²³æµ
            drawRiver(bridgeCtx);

            // ç»˜åˆ¶æ¡¥æ¢
            bridges.forEach(bridge => {
                const isVisited = gameState.visitedBridges.has(bridge.id);
                
                bridgeCtx.save();
                bridgeCtx.strokeStyle = isVisited ? '#FF6600' : '#FFD700';
                bridgeCtx.lineWidth = isVisited ? 12 : 10;
                bridgeCtx.lineCap = 'round';
                
                bridgeCtx.beginPath();
                bridgeCtx.moveTo(bridge.x1, bridge.y1);
                bridgeCtx.quadraticCurveTo(bridge.cx, bridge.cy, bridge.x2, bridge.y2);
                bridgeCtx.stroke();

                // ç»˜åˆ¶æ¡¥æ¢è¾¹æ¡†
                bridgeCtx.strokeStyle = isVisited ? '#CC5200' : '#CC9900';
                bridgeCtx.lineWidth = isVisited ? 14 : 12;
                bridgeCtx.globalAlpha = 0.3;
                bridgeCtx.stroke();
                bridgeCtx.restore();

                // ç»˜åˆ¶æ¡¥æ¢æ ‡ç­¾
                bridgeCtx.fillStyle = '#000';
                bridgeCtx.font = 'bold 12px Arial';
                bridgeCtx.fillText(bridge.label, bridge.cx - 15, bridge.cy - 10);
            });

            // ç»˜åˆ¶æ‘åº„
            Object.keys(villages).forEach(key => {
                const v = villages[key];
                const isCurrent = gameState.currentVillage === key;
                
                bridgeCtx.fillStyle = isCurrent ? '#FF6600' : '#8B4513';
                bridgeCtx.beginPath();
                bridgeCtx.arc(v.x, v.y, isCurrent ? 15 : 12, 0, Math.PI * 2);
                bridgeCtx.fill();
                
                bridgeCtx.strokeStyle = isCurrent ? '#FF9933' : '#654321';
                bridgeCtx.lineWidth = 3;
                bridgeCtx.stroke();

                bridgeCtx.fillStyle = '#000';
                bridgeCtx.font = 'bold 14px Microsoft YaHei';
                bridgeCtx.fillText(v.name, v.x - 20, v.y + 30);
            });

            // ç»˜åˆ¶è·¯å¾„
            if (gameState.path.length > 0) {
                bridgeCtx.strokeStyle = '#FF6600';
                bridgeCtx.lineWidth = 3;
                bridgeCtx.setLineDash([5, 5]);
                bridgeCtx.beginPath();
                
                gameState.path.forEach((bridgeId, index) => {
                    const bridge = bridges.find(b => b.id === bridgeId);
                    if (index === 0) {
                        bridgeCtx.moveTo(bridge.x1, bridge.y1);
                    }
                    bridgeCtx.quadraticCurveTo(bridge.cx, bridge.cy, bridge.x2, bridge.y2);
                });
                bridgeCtx.stroke();
                bridgeCtx.setLineDash([]);
            }
        }

        // ç»˜åˆ¶å›¾è®ºæ¨¡å‹
        function drawGraphModel() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

            // è®¡ç®—æ¯æ¡è¾¹åœ¨åŒå‘è¾¹ä¸­çš„ç´¢å¼•ï¼ˆç”¨äºåç§»ï¼‰
            function getEdgeIndex(bridge) {
                const sameEdges = bridges.filter(b => 
                    (b.from === bridge.from && b.to === bridge.to) ||
                    (b.from === bridge.to && b.to === bridge.from)
                );
                // æŒ‰IDæ’åºï¼Œç¡®ä¿é¡ºåºä¸€è‡´
                sameEdges.sort((a, b) => a.id - b.id);
                return sameEdges.findIndex(b => b.id === bridge.id);
            }

            // ç»˜åˆ¶è¾¹ï¼ˆæ¡¥æ¢çš„æŠ½è±¡è¡¨ç¤ºï¼‰
            bridges.forEach(bridge => {
                const isVisited = gameState.visitedBridges.has(bridge.id);
                const from = villages[bridge.from];
                const to = villages[bridge.to];

                // è®¡ç®—è¾¹çš„æ–¹å‘å‘é‡
                const dx = to.graphX - from.graphX;
                const dy = to.graphY - from.graphY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // è®¡ç®—å‚ç›´æ–¹å‘ï¼ˆç”¨äºåç§»ï¼‰
                const perpX = -dy / distance;
                const perpY = dx / distance;
                
                // è·å–è¿™æ¡è¾¹åœ¨åŒå‘è¾¹ä¸­çš„ç´¢å¼•
                const edgeIndex = getEdgeIndex(bridge);
                const totalEdges = bridges.filter(b => 
                    (b.from === bridge.from && b.to === bridge.to) ||
                    (b.from === bridge.to && b.to === bridge.from)
                ).length;
                
                // è®¡ç®—åç§»é‡ï¼ˆä½¿å¤šæ¡è¾¹åˆ†å¼€æ˜¾ç¤ºï¼‰
                const offsetDistance = (edgeIndex - (totalEdges - 1) / 2) * 15;
                const offsetX = perpX * offsetDistance;
                const offsetY = perpY * offsetDistance;
                
                // è®¡ç®—èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆè€ƒè™‘é¡¶ç‚¹åŠå¾„ï¼‰
                const vertexRadius = 20;
                const startX = from.graphX + (dx / distance) * vertexRadius + offsetX;
                const startY = from.graphY + (dy / distance) * vertexRadius + offsetY;
                const endX = to.graphX - (dx / distance) * vertexRadius + offsetX;
                const endY = to.graphY - (dy / distance) * vertexRadius + offsetY;
                
                // è®¡ç®—æ§åˆ¶ç‚¹ï¼ˆä½¿è¾¹å‘ˆç°è½»å¾®å¼¯æ›²ï¼Œæ›´æ˜“åŒºåˆ†ï¼‰
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                const curveOffset = offsetDistance * 0.3; // è½»å¾®çš„å¼¯æ›²
                const controlX = midX + perpX * curveOffset;
                const controlY = midY + perpY * curveOffset;

                graphCtx.save();
                graphCtx.strokeStyle = isVisited ? '#FF6600' : '#999';
                graphCtx.lineWidth = isVisited ? 5 : 2;
                
                graphCtx.beginPath();
                graphCtx.moveTo(startX, startY);
                graphCtx.quadraticCurveTo(controlX, controlY, endX, endY);
                graphCtx.stroke();
                graphCtx.restore();

                // ç»˜åˆ¶è¾¹çš„æ ‡ç­¾ï¼ˆåœ¨æ§åˆ¶ç‚¹ä½ç½®ï¼Œå¸¦èƒŒæ™¯ä»¥æé«˜å¯è¯»æ€§ï¼‰
                const labelX = controlX;
                const labelY = controlY - 8;
                
                // ç»˜åˆ¶æ ‡ç­¾èƒŒæ™¯
                graphCtx.save();
                graphCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                graphCtx.font = 'bold 11px Arial';
                const textMetrics = graphCtx.measureText(bridge.label);
                const textWidth = textMetrics.width;
                const textHeight = 14;
                graphCtx.fillRect(labelX - textWidth / 2 - 3, labelY - textHeight / 2, textWidth + 6, textHeight);
                graphCtx.restore();
                
                // ç»˜åˆ¶æ ‡ç­¾æ–‡å­—
                graphCtx.fillStyle = isVisited ? '#FF6600' : '#666';
                graphCtx.font = 'bold 11px Arial';
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'middle';
                graphCtx.fillText(bridge.label, labelX, labelY);
                graphCtx.textBaseline = 'alphabetic'; // æ¢å¤é»˜è®¤
            });

            // ç»˜åˆ¶é¡¶ç‚¹
            Object.keys(villages).forEach(key => {
                const v = villages[key];
                const isCurrent = gameState.currentVillage === key;
                
                graphCtx.fillStyle = isCurrent ? '#FF6600' : '#4CAF50';
                graphCtx.beginPath();
                graphCtx.arc(v.graphX, v.graphY, isCurrent ? 25 : 20, 0, Math.PI * 2);
                graphCtx.fill();
                
                graphCtx.strokeStyle = '#333';
                graphCtx.lineWidth = 3;
                graphCtx.stroke();

                // ç»˜åˆ¶æ‘åº„åç§°
                graphCtx.fillStyle = '#FFF';
                graphCtx.font = 'bold 12px Microsoft YaHei';
                graphCtx.textAlign = 'center';
                graphCtx.fillText(v.name, v.graphX, v.graphY + 5);
            });

            // ç»˜åˆ¶ç†è®ºè¯´æ˜ï¼ˆè°ƒæ•´ä½ç½®ç¡®ä¿ä¸è¢«é®æŒ¡ï¼‰
            const startY = 340; // ä»y=340å¼€å§‹ç»˜åˆ¶ï¼Œç¡®ä¿åœ¨450pxç”»å¸ƒå†…
            const lineHeight = 15; // è¡Œé—´è·ï¼Œç¨å¾®ç´§å‡‘ä¸€äº›
            
            graphCtx.fillStyle = '#000';
            graphCtx.font = 'bold 13px Microsoft YaHei';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('æ¬§æ‹‰è·¯å¾„åˆ¤å®šåŸç†ï¼š', 20, startY);
            
            graphCtx.font = '10px Microsoft YaHei';
            graphCtx.fillText('å‰æï¼šå›¾å¿…é¡»æ˜¯è¿é€šçš„', 20, startY + lineHeight);
            
            graphCtx.font = '11px Microsoft YaHei';
            graphCtx.fillText('ä¸€ä¸ªè¿é€šå›¾å­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼ˆä¸€ç¬”ç”»ï¼‰', 20, startY + lineHeight * 2);
            graphCtx.fillText('âŸº å¥‡æ•°åº¦é¡¶ç‚¹ä¸ªæ•°ä¸º 0 æˆ– 2', 20, startY + lineHeight * 3);
            
            graphCtx.font = '10px Microsoft YaHei';
            graphCtx.fillText('â€¢ 0ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ï¼šå­˜åœ¨æ¬§æ‹‰å›è·¯ï¼ˆèµ·ç‚¹=ç»ˆç‚¹ï¼‰', 20, startY + lineHeight * 4);
            graphCtx.fillText('â€¢ 2ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ï¼šå­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼ˆèµ·ç‚¹â‰ ç»ˆç‚¹ï¼‰', 20, startY + lineHeight * 5);
        }

        // è®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„åº¦æ•°
        function calculateDegrees() {
            const degrees = { 'A': 0, 'B': 0, 'C': 0, 'D': 0 };
            bridges.forEach(bridge => {
                degrees[bridge.from]++;
                degrees[bridge.to]++;
            });
            return degrees;
        }

        // æ˜¾ç¤ºåº¦æ•°ä¿¡æ¯
        function updateDegreeDisplay() {
            const degrees = calculateDegrees();
            const oddCount = Object.values(degrees).filter(d => d % 2 === 1).length;
            
            let html = '<div style="font-weight: bold; margin-bottom: 10px; color: #FF6600;">é¡¶ç‚¹åº¦æ•°åˆ†æï¼š</div>';
            Object.keys(degrees).forEach(key => {
                const village = villages[key];
                const degree = degrees[key];
                const isOdd = degree % 2 === 1;
                const className = isOdd ? 'odd-degree' : 'even-degree';
                html += `<div class="degree-item ${className}">${village.name}ï¼ˆ${key}ï¼‰: åº¦æ•° = ${degree} ${isOdd ? 'ï¼ˆå¥‡æ•°ï¼‰' : 'ï¼ˆå¶æ•°ï¼‰'}</div>`;
            });
            
            html += `<div style="margin-top: 10px; font-weight: bold;">å¥‡æ•°åº¦é¡¶ç‚¹ä¸ªæ•°ï¼š${oddCount}</div>`;
            html += `<div style="margin-top: 5px; color: ${oddCount === 0 || oddCount === 2 ? '#4CAF50' : '#D32F2F'};">`;
            if (oddCount === 0) {
                html += 'âœ“ å­˜åœ¨æ¬§æ‹‰å›è·¯ï¼ˆå¯ä»¥ä¸€ç¬”ç”»å›åˆ°èµ·ç‚¹ï¼‰';
            } else if (oddCount === 2) {
                html += 'âœ“ å­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼ˆå¯ä»¥ä¸€ç¬”ç”»ï¼Œä½†èµ·ç»ˆç‚¹ä¸åŒï¼‰';
            } else {
                html += 'âœ— ä¸å­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼ˆæ— æ³•ä¸€ç¬”ç”»å®Œï¼‰';
            }
            html += '</div>';
            
            document.getElementById('degree-info').innerHTML = html;
        }

        // å¼€å§‹ç»˜åˆ¶è·¯å¾„
        function startDrawing() {
            gameState.isDrawing = true;
            gameState.currentVillage = null;
            gameState.visitedBridges.clear();
            gameState.path = [];
            gameState.pathVertices = [];
            
            const bridgeCount = bridges.length;
            document.getElementById('status').textContent = 'è¯·é€‰æ‹©èµ·ç‚¹æ‘åº„';
            document.getElementById('bridges-crossed').textContent = `0 / ${bridgeCount}`;
            document.getElementById('current-location').textContent = 'æœªé€‰æ‹©';
            document.getElementById('feedback').className = 'feedback';
            document.getElementById('feedback').style.display = 'none';
            
            drawBridgeMap();
            drawGraphModel();
            updateDegreeDisplay();
        }

        // é‡ç½®ç”»å¸ƒ
        function resetCanvas() {
            gameState.isDrawing = false;
            gameState.currentVillage = null;
            gameState.visitedBridges.clear();
            gameState.path = [];
            gameState.pathVertices = [];
            
            const bridgeCount = bridges.length;
            document.getElementById('status').textContent = 'ç­‰å¾…å¼€å§‹';
            document.getElementById('bridges-crossed').textContent = `0 / ${bridgeCount}`;
            document.getElementById('current-location').textContent = 'æœªå¼€å§‹';
            document.getElementById('feedback').className = 'feedback';
            document.getElementById('feedback').style.display = 'none';
            
            drawBridgeMap();
            drawGraphModel();
            updateDegreeDisplay();
        }

        // å¤„ç†ç”»å¸ƒç‚¹å‡»äº‹ä»¶
        bridgeCanvas.addEventListener('click', function(event) {
            if (!gameState.isDrawing) {
                showFeedback('è¯·å…ˆç‚¹å‡»"å¼€å§‹ç»˜åˆ¶è·¯å¾„"æŒ‰é’®', 'info');
                return;
            }

            const rect = bridgeCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // å¦‚æœè¿˜æ²¡é€‰æ‹©èµ·ç‚¹ï¼Œæ£€æµ‹ç‚¹å‡»çš„æ‘åº„
            if (gameState.currentVillage === null) {
                Object.keys(villages).forEach(key => {
                    const v = villages[key];
                    const distance = Math.sqrt((x - v.x) ** 2 + (y - v.y) ** 2);
                    if (distance < 20) {
                        gameState.currentVillage = key;
                        gameState.pathVertices.push(key);
                        document.getElementById('current-location').textContent = v.name;
                        document.getElementById('status').textContent = 'ç»˜åˆ¶ä¸­...è¯·ç‚¹å‡»è¦èµ°çš„æ¡¥æ¢';
                        drawBridgeMap();
                        drawGraphModel();
                    }
                });
                return;
            }

            // æ£€æµ‹ç‚¹å‡»çš„æ¡¥æ¢
            bridges.forEach(bridge => {
                // è®¡ç®—ç‚¹åˆ°æ¡¥æ¢çš„è·ç¦»
                const distance = distanceToQuadraticCurve(x, y, bridge.x1, bridge.y1, bridge.cx, bridge.cy, bridge.x2, bridge.y2);
                
                if (distance < 20 && !gameState.visitedBridges.has(bridge.id)) {
                    // æ£€æŸ¥æ¡¥æ¢æ˜¯å¦è¿æ¥å½“å‰æ‘åº„
                    if (bridge.from === gameState.currentVillage || bridge.to === gameState.currentVillage) {
                        gameState.visitedBridges.add(bridge.id);
                        gameState.path.push(bridge.id);
                        
                        // æ›´æ–°å½“å‰ä½ç½®
                        gameState.currentVillage = (bridge.from === gameState.currentVillage) ? bridge.to : bridge.from;
                        gameState.pathVertices.push(gameState.currentVillage);
                        
                        const bridgeCount = bridges.length;
                        document.getElementById('current-location').textContent = villages[gameState.currentVillage].name;
                        document.getElementById('bridges-crossed').textContent = `${gameState.visitedBridges.size} / ${bridgeCount}`;
                        
                        drawBridgeMap();
                        drawGraphModel();

                        if (gameState.visitedBridges.size === bridgeCount) {
                            document.getElementById('status').textContent = 'å·²èµ°å®Œæ‰€æœ‰æ¡¥æ¢ï¼ç‚¹å‡»éªŒè¯æŸ¥çœ‹ç»“æœ';
                            showFeedback(`å¤ªæ£’äº†ï¼ä½ å·²ç»èµ°å®Œäº†æ‰€æœ‰${bridgeCount}åº§æ¡¥ï¼Œç‚¹å‡»"éªŒè¯è·¯å¾„"æŸ¥çœ‹ç»“æœï¼`, 'success');
                        }
                    } else {
                        showFeedback(`è¿™åº§æ¡¥ä¸è¿æ¥${villages[gameState.currentVillage].name}ï¼Œè¯·é€‰æ‹©æ­£ç¡®çš„æ¡¥æ¢`, 'error');
                    }
                }
            });
        });

        // è®¡ç®—ç‚¹åˆ°äºŒæ¬¡è´å¡å°”æ›²çº¿çš„è·ç¦»ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function distanceToQuadraticCurve(px, py, x1, y1, cx, cy, x2, y2) {
            let minDist = Infinity;
            for (let t = 0; t <= 1; t += 0.05) {
                const x = (1-t)*(1-t)*x1 + 2*(1-t)*t*cx + t*t*x2;
                const y = (1-t)*(1-t)*y1 + 2*(1-t)*t*cy + t*t*y2;
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                minDist = Math.min(minDist, dist);
            }
            return minDist;
        }

        // éªŒè¯è·¯å¾„
        function validatePath() {
            const feedback = document.getElementById('feedback');
            const bridgeCount = bridges.length;
            
            if (gameState.visitedBridges.size === 0) {
                showFeedback('ä½ è¿˜æ²¡æœ‰å¼€å§‹ç»˜åˆ¶è·¯å¾„ï¼è¯·ç‚¹å‡»"å¼€å§‹ç»˜åˆ¶è·¯å¾„"æŒ‰é’®ã€‚', 'error');
                return;
            }

            if (gameState.visitedBridges.size < bridgeCount) {
                showFeedback(`ä½ åªèµ°è¿‡äº† ${gameState.visitedBridges.size} åº§æ¡¥ï¼Œè¿˜æœ‰ ${bridgeCount - gameState.visitedBridges.size} åº§æ¡¥æ²¡æœ‰ç»è¿‡ã€‚ç»§ç»­å°è¯•å§ï¼`, 'error');
                return;
            }

            // ç†è®ºä¸Šè¿™æ˜¯ä¸å¯èƒ½å®Œæˆçš„
            const degrees = calculateDegrees();
            const oddCount = Object.values(degrees).filter(d => d % 2 === 1).length;
            
            let message = `<strong>ğŸ‰ æ­å–œï¼ä½ æ‰¾åˆ°äº†ä¸€æ¡è·¯å¾„ï¼</strong><br><br>`;
            message += `<strong>è·¯å¾„åˆ†æï¼š</strong><br>`;
            message += `èµ·ç‚¹ï¼š${villages[gameState.pathVertices[0]].name}<br>`;
            message += `ç»ˆç‚¹ï¼š${villages[gameState.pathVertices[gameState.pathVertices.length - 1]].name}<br>`;
            message += `ç»è¿‡çš„æ¡¥æ¢ï¼š${gameState.path.map(id => `æ¡¥${id}`).join(' â†’ ')}<br><br>`;
            message += `<strong>ğŸ“Š æ•°å­¦åŸç†ï¼š</strong><br>`;
            message += `å¥‡æ•°åº¦é¡¶ç‚¹ä¸ªæ•°ï¼š${oddCount}<br>`;
            
            if (oddCount === 2) {
                message += `<span style="color: #4CAF50;">âœ“ ç¬¦åˆæ¬§æ‹‰è·¯å¾„æ¡ä»¶ï¼ˆ2ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ï¼‰</span><br>`;
                message += `è¿™ä¸ªé—®é¢˜æœ‰è§£ï¼èµ·ç‚¹å’Œç»ˆç‚¹å¿…é¡»æ˜¯ä¸¤ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ã€‚`;
            } else if (oddCount === 0) {
                message += `<span style="color: #4CAF50;">âœ“ ç¬¦åˆæ¬§æ‹‰å›è·¯æ¡ä»¶ï¼ˆ0ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ï¼‰</span><br>`;
                message += `å¯ä»¥ä»ä»»æ„ç‚¹å‡ºå‘ï¼Œå›åˆ°èµ·ç‚¹ï¼`;
            }
            
            showFeedback(message, 'success');
        }

        // æ˜¾ç¤ºæç¤º
        function showHint() {
            const degrees = calculateDegrees();
            const oddVertices = Object.keys(degrees).filter(k => degrees[k] % 2 === 1).map(k => villages[k].name);
            const oddCount = oddVertices.length;
            
            let message = `<strong>ğŸ’¡ æç¤ºï¼š</strong><br><br>`;
            message += `<strong>å…³é”®è§‚å¯Ÿï¼š</strong><br>`;
            message += `å½“å‰å›¾ä¸­æœ‰ <strong>${oddCount}</strong> ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ï¼š${oddVertices.join('ã€')}<br><br>`;
            
            if (oddCount === 0 || oddCount === 2) {
                message += `<span style="color: #4CAF50;">âœ“ è¿™ä¸ªé—®é¢˜æœ‰è§£ï¼</span><br>`;
                if (oddCount === 2) {
                    message += `ä½ éœ€è¦ä»ä¸€ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹å‡ºå‘ï¼Œåœ¨å¦ä¸€ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ç»“æŸã€‚<br>`;
                    message += `å°è¯•ä» <strong>${oddVertices[0]}</strong> æˆ– <strong>${oddVertices[1]}</strong> å¼€å§‹ï¼`;
                } else {
                    message += `ä½ å¯ä»¥ä»ä»»æ„æ‘åº„å‡ºå‘ï¼Œå¹¶å›åˆ°èµ·ç‚¹ï¼`;
                }
            } else {
                message += `<span style="color: #D32F2F;">âœ— æ ¹æ®æ¬§æ‹‰å®šç†ï¼Œè¿™ä¸ªé—®é¢˜æ— è§£ï¼</span><br>`;
                message += `è¦å­˜åœ¨ä¸€ç¬”ç”»è·¯å¾„ï¼Œå¥‡æ•°åº¦é¡¶ç‚¹çš„ä¸ªæ•°å¿…é¡»æ˜¯ 0 æˆ– 2ã€‚<br>`;
                message += `å½“å‰æœ‰ ${oddCount} ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹ï¼Œæ‰€ä»¥æ— æ³•ä¸€æ¬¡ä¸é‡å¤åœ°èµ°éæ‰€æœ‰æ¡¥æ¢ã€‚`;
            }
            
            showFeedback(message, 'info');
        }

        // æ˜¾ç¤ºåŸç†
        function showTheory() {
            let message = `<strong>ğŸ“š æ¬§æ‹‰è·¯å¾„åŸç†ï¼š</strong><br><br>`;
            message += `<strong>1. åŸºæœ¬æ¦‚å¿µï¼š</strong><br>`;
            message += `â€¢ <strong>æ¬§æ‹‰è·¯å¾„</strong>ï¼šç»è¿‡å›¾ä¸­æ¯æ¡è¾¹æ°å¥½ä¸€æ¬¡çš„è·¯å¾„<br>`;
            message += `â€¢ <strong>æ¬§æ‹‰å›è·¯</strong>ï¼šèµ·ç‚¹å’Œç»ˆç‚¹ç›¸åŒçš„æ¬§æ‹‰è·¯å¾„<br>`;
            message += `â€¢ <strong>é¡¶ç‚¹çš„åº¦æ•°</strong>ï¼šä¸è¯¥é¡¶ç‚¹ç›¸è¿çš„è¾¹çš„æ•°é‡<br><br>`;
            
            message += `<strong>2. æ¬§æ‹‰å®šç†ï¼š</strong><br>`;
            message += `ä¸€ä¸ªè¿é€šå›¾å­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼Œå½“ä¸”ä»…å½“ï¼š<br>`;
            message += `â€¢ æ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°ï¼ˆå­˜åœ¨æ¬§æ‹‰å›è·¯ï¼‰<br>`;
            message += `â€¢ æ°æœ‰ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦æ•°æ˜¯å¥‡æ•°ï¼ˆå­˜åœ¨æ¬§æ‹‰è·¯å¾„ï¼‰<br><br>`;
            
            message += `<strong>3. ä¸ºä»€ä¹ˆï¼Ÿ</strong><br>`;
            message += `æƒ³è±¡ä½ æ¯æ¬¡ç»è¿‡ä¸€ä¸ªæ‘åº„ï¼š<br>`;
            message += `â€¢ å¦‚æœæ˜¯<strong>ä¸­é€”ç»è¿‡</strong>ï¼Œä½ éœ€è¦"è¿›å…¥ä¸€åº§æ¡¥ï¼Œç¦»å¼€ä¸€åº§æ¡¥"ï¼ˆæ¶ˆè€—2ä¸ªåº¦æ•°ï¼‰<br>`;
            message += `â€¢ å¦‚æœæ˜¯<strong>èµ·ç‚¹æˆ–ç»ˆç‚¹</strong>ï¼Œåªéœ€è¦ç¦»å¼€æˆ–è¿›å…¥ï¼ˆæ¶ˆè€—1ä¸ªåº¦æ•°ï¼‰<br>`;
            message += `â€¢ æ‰€ä»¥ï¼Œé™¤äº†èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œå…¶ä»–æ‘åº„çš„åº¦æ•°å¿…é¡»æ˜¯å¶æ•°ï¼<br><br>`;
            
            const degrees = calculateDegrees();
            const oddCount = Object.values(degrees).filter(d => d % 2 === 1).length;
            
            message += `<strong>4. å½“å‰é—®é¢˜åˆ†æï¼š</strong><br>`;
            message += `æœ¬é¢˜æœ‰ <strong>${oddCount}</strong> ä¸ªå¥‡æ•°åº¦é¡¶ç‚¹<br>`;
            if (oddCount > 2) {
                message += `<span style="color: #D32F2F;">å› æ­¤ï¼Œè¿™ä¸ªä¸ƒæ¡¥é—®é¢˜æ— è§£ï¼</span><br>`;
                message += `è¿™å°±æ˜¯å†å²ä¸Šè‘—åçš„<strong>å“¥å°¼æ–¯å ¡ä¸ƒæ¡¥é—®é¢˜</strong>ï¼Œæ¬§æ‹‰åœ¨1736å¹´è¯æ˜äº†å®ƒæ— è§£ï¼Œå¹¶ç”±æ­¤å¼€åˆ›äº†å›¾è®ºè¿™é—¨å­¦ç§‘ï¼`;
            } else {
                message += `<span style="color: #4CAF50;">å› æ­¤ï¼Œè¿™ä¸ªé—®é¢˜æœ‰è§£ï¼</span>`;
            }
            
            showFeedback(message, 'info');
        }

        // æ˜¾ç¤ºåé¦ˆä¿¡æ¯
        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.innerHTML = message;
            feedback.className = `feedback ${type}`;
        }

        // åˆå§‹åŒ–
        updateDegreeDisplay();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>