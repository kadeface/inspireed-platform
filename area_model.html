<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¢ç§¯æ¨¡å‹ä¹˜æ³•æ¸¸æˆ - äº’åŠ¨å­¦ä¹ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            overflow: hidden;
            margin: 0;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 24px;
            font-weight: bold;
        }

        .stats {
            display: flex;
            gap: 30px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .left-panel {
            width: 240px;
            min-width: 240px;
            background: #f8f9fa;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border-right: 2px solid #e0e0e0;
            overflow-y: auto;
        }

        .level-info {
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .level-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .level-description {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
        }

        .question-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 12px;
            padding: 15px;
            color: white;
            text-align: center;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }

        .question-text {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .question-hint {
            font-size: 14px;
            opacity: 0.9;
        }

        .controls {
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 14px;
            color: #333;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            background: #e0e0e0;
            color: #333;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            width: 100%;
            padding: 12px;
            font-size: 16px;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 50%, #e8f5e9 100%);
            position: relative;
            min-width: 0;
        }

        .canvas-wrapper {
            position: relative;
            border: 2px solid #333;
            border-radius: 10px;
            background: white;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        .axis-labels {
            position: absolute;
            pointer-events: none;
        }

        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 50px 100px;
            border-radius: 30px;
            font-size: 64px;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 4px solid rgba(255, 255, 255, 0.8);
        }

        .feedback.show {
            opacity: 1;
            animation: feedbackPop 0.8s ease-out;
        }

        .feedback.correct {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 50%, #43a047 100%);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feedback.wrong {
            background: linear-gradient(135deg, #ff7043 0%, #ff5722 50%, #e64a19 100%);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        @keyframes feedbackPop {
            0% {
                transform: translate(-50%, -50%) scale(0.2) rotate(-10deg);
                opacity: 0;
            }
            30% {
                transform: translate(-50%, -50%) scale(1.2) rotate(5deg);
            }
            60% {
                transform: translate(-50%, -50%) scale(0.95) rotate(-2deg);
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes sparkle {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }

        .feedback.correct::before {
            content: 'âœ¨';
            position: absolute;
            left: -30px;
            top: 50%;
            transform: translateY(-50%);
            animation: sparkle 0.6s ease-in-out infinite;
        }

        .feedback.correct::after {
            content: 'âœ¨';
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            animation: sparkle 0.6s ease-in-out infinite 0.3s;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            transition: width 0.3s;
            border-radius: 4px;
        }

        .instruction {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            font-size: 12px;
            color: #856404;
            line-height: 1.5;
        }

        .instruction-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .mode-indicator {
            display: inline-block;
            padding: 6px 12px;
            background: #e3f2fd;
            border-radius: 6px;
            font-size: 12px;
            color: #1976d2;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>ğŸ® é¢ç§¯æ¨¡å‹ä¹˜æ³•æ¸¸æˆ</h1>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">å¾—åˆ†</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">æ­£ç¡®</div>
                    <div class="stat-value" id="correctCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å…³å¡</div>
                    <div class="stat-value" id="level">1</div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="level-info">
                    <div class="level-title" id="levelTitle">ç¬¬1å…³ï¼šåŸºç¡€å…¥é—¨</div>
                    <div class="level-description" id="levelDescription">
                        å­¦ä¹ 1-5çš„ä¹˜æ³•å£è¯€ï¼Œé€šè¿‡ç‚¹å‡»ç½‘æ ¼æ¥ç†è§£é¢ç§¯ä¸ä¹˜æ³•çš„å…³ç³»ã€‚
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="levelProgress" style="width: 0%"></div>
                    </div>
                </div>

                <div class="question-card">
                    <div class="question-text" id="questionText">å‡†å¤‡å¼€å§‹</div>
                    <div class="question-hint" id="questionHint">ç‚¹å‡»ç½‘æ ¼ä¸­çš„æ•°å­—æ¥å›ç­”</div>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <div class="control-label">æ¸¸æˆæ¨¡å¼</div>
                        <div class="button-group">
                            <button class="btn active" id="multiplyMode" onclick="setGameMode('multiply')">ä¹˜æ³•</button>
                            <button class="btn" id="divideMode" onclick="setGameMode('divide')">é™¤æ³•</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">äº¤äº’æ¨¡å¼</div>
                        <div class="button-group">
                            <button class="btn active" id="clickMode" onclick="setInteractionMode('click')">ç‚¹å‡»</button>
                            <button class="btn" id="dragMode" onclick="setInteractionMode('drag')">æ‹–æ‹½</button>
                        </div>
                        <div class="mode-indicator" id="modeIndicator">å½“å‰æ¨¡å¼ï¼šç‚¹å‡»é€‰æ‹©</div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">æ˜¾ç¤ºé€‰é¡¹</div>
                        <div class="button-group">
                            <button class="btn active" id="showGrid" onclick="toggleOption('grid')">ç½‘æ ¼</button>
                            <button class="btn active" id="showNumbers" onclick="toggleOption('numbers')">æ•°å­—</button>
                            <button class="btn active" id="showArea" onclick="toggleOption('area')">é¢ç§¯</button>
                        </div>
                    </div>

                    <button class="btn btn-primary" onclick="nextQuestion()">ä¸‹ä¸€é¢˜</button>
                    <button class="btn btn-primary" onclick="resetGame()" style="margin-top: 10px; background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);">é‡æ–°å¼€å§‹</button>
                </div>

                <div class="instruction">
                    <div class="instruction-title">ğŸ’¡ æ¸¸æˆè¯´æ˜</div>
                    <div>â€¢ ç‚¹å‡»æ¨¡å¼ï¼šç‚¹å‡»ç½‘æ ¼ä¸­çš„æ•°å­—æ¥å›ç­”</div>
                    <div>â€¢ æ‹–æ‹½æ¨¡å¼ï¼šæ‹–æ‹½é¼ æ ‡ç»˜åˆ¶çŸ©å½¢åŒºåŸŸ</div>
                    <div>â€¢ é«˜äº®æ¨¡å¼ï¼šé¼ æ ‡æ‚¬åœé«˜äº®æ˜¾ç¤ºé¢ç§¯</div>
                    <div>â€¢ ç†è§£ä¹˜æ³• = é•¿ Ã— å®½ = é¢ç§¯</div>
                </div>
            </div>

            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="feedback" id="feedback"></div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            canvas: null,
            ctx: null,
            gridSize: 12, // 
            cellSize: 0,
            offsetX: 0,
            offsetY: 0,
            gridOffsetX: 40, // ç½‘æ ¼åœ¨Canvasä¸­çš„Xåç§»ï¼ˆä¸ºåæ ‡è½´æ ‡ç­¾é¢„ç•™ç©ºé—´ï¼‰
            gridOffsetY: 40, // ç½‘æ ¼åœ¨Canvasä¸­çš„Yåç§»ï¼ˆä¸ºåæ ‡è½´æ ‡ç­¾é¢„ç•™ç©ºé—´ï¼‰
            currentQuestion: null,
            score: 0,
            correctCount: 0,
            wrongCount: 0,
            level: 1,
            levelProgress: 0,
            interactionMode: 'click', // 'click', 'drag', 'highlight'
            gameMode: 'multiply', // 'multiply' æˆ– 'divide'
            showGrid: true,
            showNumbers: true,
            showArea: true,
            isDragging: false,
            dragStart: null,
            dragEnd: null,
            selectedCells: new Set(),
            hoveredCell: null,
            canAnswer: true
        };

        // å…³å¡é…ç½®
        const levels = [
            {
                title: 'ç¬¬1å…³ï¼šåŸºç¡€å…¥é—¨',
                description: 'å­¦ä¹ 1-5çš„ä¹˜æ³•å£è¯€ï¼Œé€šè¿‡ç‚¹å‡»ç½‘æ ¼æ¥ç†è§£é¢ç§¯ä¸ä¹˜æ³•çš„å…³ç³»ã€‚',
                minFactor: 1,
                maxFactor: 5,
                questionsPerLevel: 10
            },
            {
                title: 'ç¬¬2å…³ï¼šè¿›é˜¶ç»ƒä¹ ',
                description: 'æŒæ¡6-8çš„ä¹˜æ³•å£è¯€ï¼ŒåŠ æ·±å¯¹é¢ç§¯æ¨¡å‹çš„ç†è§£ã€‚',
                minFactor: 6,
                maxFactor: 8,
                questionsPerLevel: 12
            },
            {
                title: 'ç¬¬3å…³ï¼šé«˜çº§æŒ‘æˆ˜',
                description: 'æŒ‘æˆ˜9-12çš„ä¹˜æ³•å£è¯€ï¼Œç†Ÿç»ƒæŒæ¡é¢ç§¯è®¡ç®—æ–¹æ³•ã€‚',
                minFactor: 9,
                maxFactor: 12,
                questionsPerLevel: 15
            },
            {
                title: 'ç¬¬4å…³ï¼šç»¼åˆåº”ç”¨',
                description: 'æ··åˆç»ƒä¹ æ‰€æœ‰ä¹˜æ³•å£è¯€ï¼Œå·©å›ºå­¦ä¹ æˆæœã€‚',
                minFactor: 1,
                maxFactor: 12,
                questionsPerLevel: 20
            }
        ];

        let currentLevelQuestions = [];
        let usedQuestions = [];
        let currentLevelQuestionCount = 0; // å½“å‰å…³å¡å·²å®Œæˆçš„é¢˜ç›®æ•°

        // åˆå§‹åŒ–Canvas
        function initCanvas() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // äº‹ä»¶ç›‘å¬
            gameState.canvas.addEventListener('mousedown', (e) => {
                if (!gameState.canAnswer || !gameState.currentQuestion) return;
                
                const pos = getGridPosition(e);
                if (pos.row < 0 || pos.row >= gameState.gridSize || 
                    pos.col < 0 || pos.col >= gameState.gridSize) return;
                
                if (gameState.interactionMode === 'click') {
                    // ç‚¹å‡»æ¨¡å¼ï¼šé€‰æ‹©å•ä¸ªå•å…ƒæ ¼
                    const cellKey = `${pos.row},${pos.col}`;
                    const number = pos.row * gameState.gridSize + pos.col + 1;
                    
                    if (gameState.currentQuestion.type === 'multiply') {
                        // ä¹˜æ³•æ¨¡å¼
                        if (number === gameState.currentQuestion.answer) {
                            // é€‰ä¸­æ•´ä¸ªçŸ©å½¢åŒºåŸŸ
                            const { factor1, factor2 } = gameState.currentQuestion;
                            gameState.selectedCells.clear();
                            
                            for (let r = 0; r < factor1; r++) {
                                for (let c = 0; c < factor2; c++) {
                                    gameState.selectedCells.add(`${r},${c}`);
                                }
                            }
                            
                            draw();
                            checkAnswer(number);
                        } else {
                            // é”™è¯¯ç­”æ¡ˆï¼Œæ˜¾ç¤ºåé¦ˆ
                            gameState.selectedCells.clear();
                            gameState.selectedCells.add(cellKey);
                            draw();
                            checkAnswer(number);
                        }
                    } else {
                        // é™¤æ³•æ¨¡å¼ï¼šç‚¹å‡»æ•°å­—ä½œä¸ºç­”æ¡ˆï¼ˆå•†ï¼‰
                        if (number === gameState.currentQuestion.answer) {
                            // é€‰ä¸­æ•´ä¸ªçŸ©å½¢åŒºåŸŸï¼šé¢ç§¯ = areaï¼Œä¸€æ¡è¾¹ = divisorï¼Œå¦ä¸€æ¡è¾¹ = answer
                            const { area, divisor, answer, factor1, factor2 } = gameState.currentQuestion;
                            gameState.selectedCells.clear();
                            
                            // æ ¹æ®factor1å’Œfactor2ç»˜åˆ¶çŸ©å½¢
                            for (let r = 0; r < factor1; r++) {
                                for (let c = 0; c < factor2; c++) {
                                    gameState.selectedCells.add(`${r},${c}`);
                                }
                            }
                            
                            draw();
                            checkAnswer(number);
                        } else {
                            // é”™è¯¯ç­”æ¡ˆï¼Œæ˜¾ç¤ºåé¦ˆ
                            gameState.selectedCells.clear();
                            gameState.selectedCells.add(cellKey);
                            draw();
                            checkAnswer(number);
                        }
                    }
                } else if (gameState.interactionMode === 'drag') {
                    // æ‹–æ‹½æ¨¡å¼ï¼šå¼€å§‹æ‹–æ‹½
                    gameState.isDragging = true;
                    gameState.dragStart = pos;
                    gameState.dragEnd = pos;
                }
            });

            gameState.canvas.addEventListener('mousemove', (e) => {
                const pos = getGridPosition(e);
                
                if (gameState.interactionMode === 'highlight') {
                    // é«˜äº®æ¨¡å¼ï¼šæ›´æ–°æ‚¬åœå•å…ƒæ ¼
                    if (pos.row >= 0 && pos.row < gameState.gridSize && 
                        pos.col >= 0 && pos.col < gameState.gridSize) {
                        gameState.hoveredCell = pos;
                        draw();
                    } else {
                        gameState.hoveredCell = null;
                        draw();
                    }
                } else if (gameState.interactionMode === 'drag' && gameState.isDragging) {
                    // æ‹–æ‹½æ¨¡å¼ï¼šæ›´æ–°æ‹–æ‹½ç»“æŸä½ç½®
                    gameState.dragEnd = pos;
                    draw();
                }
            });

            gameState.canvas.addEventListener('mouseup', (e) => {
                if (gameState.interactionMode === 'drag' && gameState.isDragging) {
                    const pos = getGridPosition(e);
                    gameState.dragEnd = pos;
                    gameState.isDragging = false;
                    
                    if (gameState.dragStart && gameState.dragEnd && 
                        gameState.dragStart.row >= 0 && gameState.dragStart.col >= 0 &&
                        gameState.dragEnd.row >= 0 && gameState.dragEnd.col >= 0) {
                        const startRow = Math.min(gameState.dragStart.row, gameState.dragEnd.row);
                        const endRow = Math.max(gameState.dragStart.row, gameState.dragEnd.row);
                        const startCol = Math.min(gameState.dragStart.col, gameState.dragEnd.col);
                        const endCol = Math.max(gameState.dragStart.col, gameState.dragEnd.col);
                        
                        const width = endCol - startCol + 1;
                        const height = endRow - startRow + 1;
                        const area = width * height;
                        
                        // é€‰ä¸­æ‹–æ‹½åŒºåŸŸ
                        gameState.selectedCells.clear();
                        for (let r = startRow; r <= endRow; r++) {
                            for (let c = startCol; c <= endCol; c++) {
                                gameState.selectedCells.add(`${r},${c}`);
                            }
                        }
                        
                        draw();
                        checkAnswer(area);
                    }
                    
                    gameState.dragStart = null;
                    gameState.dragEnd = null;
                }
            });

            gameState.canvas.addEventListener('mouseleave', () => {
                gameState.hoveredCell = null;
                if (gameState.interactionMode === 'drag') {
                    gameState.isDragging = false;
                }
                draw();
            });
        }

        // è°ƒæ•´Canvaså¤§å°
        function resizeCanvas() {
            const wrapper = gameState.canvas.parentElement;
            // å¢åŠ æœ€å¤§å°ºå¯¸é™åˆ¶ï¼Œæ›´å¥½åœ°åˆ©ç”¨å±å¹•ç©ºé—´
            const availableWidth = wrapper.clientWidth - 20;
            const availableHeight = wrapper.clientHeight - 20;
            // ä½¿ç”¨æ›´å¤§çš„æœ€å¤§å°ºå¯¸ï¼Œä¼˜å…ˆä½¿ç”¨å¯ç”¨ç©ºé—´ï¼Œç§»é™¤ä¸Šé™æˆ–è®¾ç½®æ›´å¤§çš„ä¸Šé™
            const maxSize = Math.min(availableWidth, availableHeight);
            // ç¡®ä¿æœ€å°å°ºå¯¸ï¼Œä½†å…è®¸æ›´å¤§çš„å•å…ƒæ ¼
            const minSize = gameState.gridSize * 55; // æ¯ä¸ªå•å…ƒæ ¼è‡³å°‘35pxï¼ˆç½‘æ ¼æ‰©å¤§åç¨å¾®å‡å°ä»¥é€‚é…ï¼‰
            const gridSize = Math.max(minSize, Math.floor(maxSize / gameState.gridSize) * gameState.gridSize);
            
            // ä¸ºåæ ‡è½´æ ‡ç­¾é¢„ç•™ç©ºé—´ï¼ˆå·¦å³å„40pxï¼Œä¸Šä¸‹å„40pxï¼‰
            const labelSpace = 40;
            const totalSize = gridSize + labelSpace * 2;
            
            // è®¾ç½®Canvasçš„å®é™…åƒç´ å¤§å°
            gameState.canvas.width = totalSize;
            gameState.canvas.height = totalSize;
            
            // è®¾ç½®Canvasçš„æ˜¾ç¤ºå¤§å°ï¼ˆCSSï¼‰
            gameState.canvas.style.width = totalSize + 'px';
            gameState.canvas.style.height = totalSize + 'px';
            
            gameState.cellSize = gridSize / gameState.gridSize;
            gameState.gridOffsetX = labelSpace;
            gameState.gridOffsetY = labelSpace;
            gameState.offsetX = (wrapper.clientWidth - totalSize) / 2;
            gameState.offsetY = (wrapper.clientHeight - totalSize) / 2;
            
            // ç¡®ä¿cellSizeæœ‰æ•ˆ
            if (gameState.cellSize <= 0) {
                gameState.cellSize = 40; // é»˜è®¤å€¼
            }
            
            draw();
        }

        // è·å–é¼ æ ‡åœ¨ç½‘æ ¼ä¸­çš„ä½ç½®
        function getGridPosition(e) {
            const rect = gameState.canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // å‡å»ç½‘æ ¼åç§»é‡
            const offsetX = gameState.gridOffsetX || 0;
            const offsetY = gameState.gridOffsetY || 0;
            const gridX = canvasX - offsetX;
            const gridY = canvasY - offsetY;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨ç½‘æ ¼èŒƒå›´å†…
            if (gridX < 0 || gridY < 0) {
                return { row: -1, col: -1, x: canvasX, y: canvasY };
            }
            
            const col = Math.floor(gridX / gameState.cellSize);
            const row = Math.floor(gridY / gameState.cellSize);
            
            // æ£€æŸ¥æ˜¯å¦è¶…å‡ºç½‘æ ¼èŒƒå›´
            if (row < 0 || row >= gameState.gridSize || col < 0 || col >= gameState.gridSize) {
                return { row: -1, col: -1, x: canvasX, y: canvasY };
            }
            
            return { row, col, x: canvasX, y: canvasY };
        }

        // ç”Ÿæˆå½“å‰å…³å¡çš„é¢˜ç›®
        function generateLevelQuestions() {
            const level = levels[gameState.level - 1];
            const questions = [];
            
            if (gameState.gameMode === 'multiply') {
                // ä¹˜æ³•æ¨¡å¼ï¼šç”Ÿæˆä¹˜æ³•é¢˜ç›®
                for (let i = level.minFactor; i <= level.maxFactor; i++) {
                    for (let j = level.minFactor; j <= level.maxFactor; j++) {
                        questions.push({
                            type: 'multiply',
                            factor1: i,
                            factor2: j,
                            answer: i * j,
                            text: `${i} Ã— ${j} = ?`
                        });
                    }
                }
            } else {
                // é™¤æ³•æ¨¡å¼ï¼šç”Ÿæˆé™¤æ³•é¢˜ç›®
                // å·²çŸ¥é¢ç§¯ï¼ˆè¢«é™¤æ•°ï¼‰å’Œä¸€æ¡è¾¹ï¼ˆé™¤æ•°ï¼‰ï¼Œæ±‚å¦ä¸€æ¡è¾¹ï¼ˆå•†ï¼‰
                for (let i = level.minFactor; i <= level.maxFactor; i++) {
                    for (let j = level.minFactor; j <= level.maxFactor; j++) {
                        const area = i * j; // é¢ç§¯ï¼ˆè¢«é™¤æ•°ï¼‰
                        // ç”Ÿæˆä¸¤ç§é™¤æ³•é¢˜ç›®ï¼šarea Ã· i = j å’Œ area Ã· j = i
                        questions.push({
                            type: 'divide',
                            area: area, // è¢«é™¤æ•°ï¼ˆé¢ç§¯ï¼‰
                            divisor: i, // é™¤æ•°ï¼ˆå·²çŸ¥è¾¹ï¼‰
                            answer: j, // å•†ï¼ˆå¦ä¸€æ¡è¾¹ï¼‰
                            factor1: i, // ç”¨äºç»˜åˆ¶å·²çŸ¥è¾¹
                            factor2: j, // ç”¨äºç»˜åˆ¶ç­”æ¡ˆè¾¹
                            text: `${area} Ã· ${i} = ?`
                        });
                        // é¿å…é‡å¤ï¼ˆå½“ i === j æ—¶ï¼‰
                        if (i !== j) {
                            questions.push({
                                type: 'divide',
                                area: area,
                                divisor: j,
                                answer: i,
                                factor1: j,
                                factor2: i,
                                text: `${area} Ã· ${j} = ?`
                            });
                        }
                    }
                }
            }
            
            // æ‰“ä¹±é¡ºåº
            return questions.sort(() => Math.random() - 0.5);
        }

        // è·å–ä¸‹ä¸€é¢˜
        function getNextQuestion() {
            const currentLevel = levels[gameState.level - 1];
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å®Œæˆäº†å…³å¡è¦æ±‚çš„é¢˜ç›®æ•°
            if (currentLevelQuestionCount >= currentLevel.questionsPerLevel) {
                // å…³å¡å·²å®Œæˆï¼Œè¿”å›nullï¼Œè®©checkAndAdvanceLevelå¤„ç†
                return null;
            }
            
            // ä»å½“å‰å…³å¡çš„é¢˜ç›®ä¸­é€‰æ‹©
            const available = currentLevelQuestions.filter(q => 
                !usedQuestions.some(uq => uq.factor1 === q.factor1 && uq.factor2 === q.factor2)
            );
            
            // å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½ç”¨å®Œäº†ï¼Œä½†è¿˜æ²¡è¾¾åˆ°è¦æ±‚çš„é¢˜ç›®æ•°ï¼Œé‡æ–°å¼€å§‹
            if (available.length === 0) {
                // é‡ç½®å·²ä½¿ç”¨çš„é¢˜ç›®åˆ—è¡¨ï¼Œå…è®¸é‡å¤ä½¿ç”¨é¢˜ç›®
                usedQuestions = [];
                return getNextQuestion();
            }
            
            const question = available[Math.floor(Math.random() * available.length)];
            usedQuestions.push(question);
            return question;
        }
        
        // æ£€æŸ¥å¹¶åˆ‡æ¢å…³å¡
        function checkAndAdvanceLevel() {
            const currentLevel = levels[gameState.level - 1];
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆäº†å½“å‰å…³å¡è¦æ±‚çš„é¢˜ç›®æ•°
            if (currentLevelQuestionCount >= currentLevel.questionsPerLevel) {
                // å…³å¡å®Œæˆï¼Œè¿›å…¥ä¸‹ä¸€å…³
                if (gameState.level < levels.length) {
                    // æ˜¾ç¤ºå…³å¡å®Œæˆæç¤º
                    const feedback = document.getElementById('feedback');
                    feedback.textContent = `ğŸ‰ ç¬¬${gameState.level}å…³å®Œæˆï¼`;
                    feedback.className = 'feedback correct show';
                    
                    setTimeout(() => {
                        feedback.classList.remove('show');
                        
                        // åˆ‡æ¢åˆ°ä¸‹ä¸€å…³
                        gameState.level++;
                        gameState.levelProgress = 0;
                        currentLevelQuestions = generateLevelQuestions();
                        usedQuestions = [];
                        currentLevelQuestionCount = 0; // é‡ç½®å½“å‰å…³å¡é¢˜ç›®è®¡æ•°
                        updateLevelInfo();
                        updateStats();
                        
                        // ç»§ç»­è·å–ä¸‹ä¸€é¢˜
                        nextQuestion();
                    }, 2000);
                    
                    return true; // è¡¨ç¤ºå…³å¡å·²åˆ‡æ¢
                } else {
                    // æ‰€æœ‰å…³å¡å®Œæˆ
                    const feedback = document.getElementById('feedback');
                    feedback.textContent = 'ğŸ‰ æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰å…³å¡ï¼';
                    feedback.className = 'feedback correct show';
                    return true;
                }
            }
            
            return false; // å…³å¡æœªå®Œæˆï¼Œç»§ç»­å½“å‰å…³å¡
        }

        // æ˜¾ç¤ºä¸‹ä¸€é¢˜
        function nextQuestion() {
            gameState.canAnswer = true;
            gameState.selectedCells.clear();
            gameState.dragStart = null;
            gameState.dragEnd = null;
            gameState.currentQuestion = getNextQuestion();
            
            if (!gameState.currentQuestion) return;
            
            document.getElementById('questionText').textContent = gameState.currentQuestion.text;
            
            // æ ¹æ®æ¸¸æˆæ¨¡å¼æ˜¾ç¤ºä¸åŒçš„æç¤º
            if (gameState.currentQuestion.type === 'multiply') {
                document.getElementById('questionHint').textContent = 
                    `åœ¨ç½‘æ ¼ä¸­æ‰¾å‡º ${gameState.currentQuestion.factor1} Ã— ${gameState.currentQuestion.factor2} çš„é¢ç§¯`;
            } else {
                // é™¤æ³•æ¨¡å¼ï¼šå·²çŸ¥é¢ç§¯å’Œä¸€æ¡è¾¹ï¼Œæ±‚å¦ä¸€æ¡è¾¹
                document.getElementById('questionHint').textContent = 
                    `é¢ç§¯æ˜¯ ${gameState.currentQuestion.area}ï¼Œ${gameState.currentQuestion.divisor} æ˜¯å·²çŸ¥è¾¹ï¼Œæ‰¾å‡ºå¦ä¸€æ¡è¾¹æ˜¯å¤šå°‘`;
            }
            
            updateLevelProgress();
            draw();
        }

        // æ£€æŸ¥ç­”æ¡ˆ
        function checkAnswer(answer) {
            if (!gameState.canAnswer || !gameState.currentQuestion) return;
            
            let isCorrect = false;
            
            if (gameState.currentQuestion.type === 'multiply') {
                // ä¹˜æ³•æ¨¡å¼ï¼šç›´æ¥æ¯”è¾ƒç­”æ¡ˆ
                isCorrect = answer === gameState.currentQuestion.answer;
            } else {
                // é™¤æ³•æ¨¡å¼ï¼šéœ€è¦éªŒè¯é€‰ä¸­åŒºåŸŸçš„é¢ç§¯å’Œè¾¹
                // answer æ˜¯é€‰ä¸­åŒºåŸŸçš„é¢ç§¯æˆ–é€‰ä¸­çš„æ•°å­—
                // éœ€è¦æ£€æŸ¥ï¼šé¢ç§¯ = areaï¼Œä¸”ä¸€æ¡è¾¹ = divisorï¼Œå¦ä¸€æ¡è¾¹ = answer
                if (gameState.selectedCells.size > 0) {
                    const selectedArea = gameState.selectedCells.size;
                    // è·å–é€‰ä¸­åŒºåŸŸçš„å°ºå¯¸
                    const cells = Array.from(gameState.selectedCells).map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    });
                    
                    const minRow = Math.min(...cells.map(c => c.row));
                    const maxRow = Math.max(...cells.map(c => c.row));
                    const minCol = Math.min(...cells.map(c => c.col));
                    const maxCol = Math.max(...cells.map(c => c.col));
                    
                    const width = maxCol - minCol + 1;
                    const height = maxRow - minRow + 1;
                    
                    // éªŒè¯ï¼šé¢ç§¯ = areaï¼Œä¸”ä¸€æ¡è¾¹ = divisorï¼Œå¦ä¸€æ¡è¾¹ = answer
                    if (selectedArea === gameState.currentQuestion.area) {
                        if ((width === gameState.currentQuestion.divisor && height === gameState.currentQuestion.answer) ||
                            (height === gameState.currentQuestion.divisor && width === gameState.currentQuestion.answer)) {
                            isCorrect = true;
                        }
                    }
                } else {
                    // ç‚¹å‡»æ¨¡å¼ï¼šç›´æ¥æ¯”è¾ƒæ•°å­—ç­”æ¡ˆ
                    isCorrect = answer === gameState.currentQuestion.answer;
                }
            }
            
            gameState.canAnswer = false;
            
            if (isCorrect) {
                gameState.correctCount++;
                gameState.score += 10;
                showFeedback(true);
                
                // å¢åŠ å½“å‰å…³å¡å·²å®Œæˆçš„é¢˜ç›®æ•°
                currentLevelQuestionCount++;
                updateLevelProgress();
                
                // æ£€æŸ¥æ˜¯å¦å®Œæˆå…³å¡ï¼ˆåœ¨æ˜¾ç¤ºåé¦ˆåï¼‰
                setTimeout(() => {
                    const levelAdvanced = checkAndAdvanceLevel();
                    if (!levelAdvanced) {
                        // å…³å¡æœªå®Œæˆï¼Œç»§ç»­ä¸‹ä¸€é¢˜
                        nextQuestion();
                    }
                }, 1500);
            } else {
                gameState.wrongCount++;
                gameState.score = Math.max(0, gameState.score - 2);
                showFeedback(false);
                
                setTimeout(() => {
                    gameState.canAnswer = true;
                    gameState.selectedCells.clear();
                    draw();
                }, 1500);
            }
            
            updateStats();
        }

        // ç»˜åˆ¶ç½‘æ ¼
        function draw() {
            const { ctx, cellSize, gridSize } = gameState;
            
            // æ£€æŸ¥canvaså’Œctxæ˜¯å¦æœ‰æ•ˆ
            if (!ctx || !gameState.canvas || cellSize <= 0) {
                console.error('Canvas not initialized properly');
                return;
            }
            
            const offsetX = gameState.gridOffsetX || 0;
            const offsetY = gameState.gridOffsetY || 0;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯ - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
            ctx.fillStyle = '#f0f8ff'; // æµ…è“è‰²èƒŒæ™¯ï¼Œæ›´ç¬¦åˆå„¿ç«¥åå¥½
            ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯åŒºåŸŸ - ä½¿ç”¨æ¸å˜è‰²
            const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + gridSize * cellSize, offsetY + gridSize * cellSize);
            gradient.addColorStop(0, '#fff5f5'); // æµ…ç²‰è‰²
            gradient.addColorStop(0.5, '#f0f8ff'); // æµ…è“è‰²
            gradient.addColorStop(1, '#f5fff5'); // æµ…ç»¿è‰²
            ctx.fillStyle = gradient;
            ctx.fillRect(offsetX, offsetY, gridSize * cellSize, gridSize * cellSize);
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿ - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
            if (gameState.showGrid) {
                ctx.strokeStyle = '#ff6b9d'; // ç²‰çº¢è‰²ç½‘æ ¼çº¿
                ctx.lineWidth = 1.5;
                
                for (let i = 0; i <= gridSize; i++) {
                    const pos = i * cellSize;
                    // å‚ç›´çº¿
                    ctx.beginPath();
                    ctx.moveTo(offsetX + pos, offsetY);
                    ctx.lineTo(offsetX + pos, offsetY + gridSize * cellSize);
                    ctx.stroke();
                    
                    // æ°´å¹³çº¿
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY + pos);
                    ctx.lineTo(offsetX + gridSize * cellSize, offsetY + pos);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å¤–è¾¹æ¡†ï¼ˆæ›´ç²—ï¼Œæ›´é²œæ˜çš„é¢œè‰²ï¼‰
                ctx.strokeStyle = '#ff4081'; // é²œè‰³çš„ç²‰çº¢è‰²
                ctx.lineWidth = 3;
                ctx.strokeRect(offsetX, offsetY, gridSize * cellSize, gridSize * cellSize);
            }
            
            // ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾ - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
            ctx.fillStyle = '#ff4081'; // é²œè‰³çš„ç²‰çº¢è‰²
            const labelFontSize = Math.max(12, Math.min(18, cellSize * 0.3));
            ctx.font = `bold ${labelFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Xè½´æ ‡ç­¾ï¼ˆé¡¶éƒ¨ï¼Œåœ¨ç½‘æ ¼ä¸Šæ–¹ï¼‰
            for (let i = 0; i < gridSize; i++) {
                const x = offsetX + (i + 0.5) * cellSize;
                const y = offsetY - 20; // åœ¨ç½‘æ ¼ä¸Šæ–¹20px
                ctx.fillText((i + 1).toString(), x, y);
            }
            
            // Yè½´æ ‡ç­¾ï¼ˆå·¦ä¾§ï¼Œåœ¨ç½‘æ ¼å·¦è¾¹ï¼‰
            for (let i = 0; i < gridSize; i++) {
                const x = offsetX - 20; // åœ¨ç½‘æ ¼å·¦è¾¹20px
                const y = offsetY + (i + 0.5) * cellSize;
                ctx.fillText((i + 1).toString(), x, y);
            }
            
            // ç»˜åˆ¶é™¤æ³•æ¨¡å¼ä¸‹çš„é¢ç§¯åŒºåŸŸå’Œå·²çŸ¥è¾¹ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
            if (gameState.currentQuestion && gameState.currentQuestion.type === 'divide') {
                const { divisor, area, answer, factor1, factor2 } = gameState.currentQuestion;
                
                // ç¡®å®šå·²çŸ¥è¾¹æ˜¯å®½åº¦è¿˜æ˜¯é«˜åº¦ï¼ˆæ ¹æ®factor1å’Œfactor2ï¼‰
                // å¦‚æœfactor1æ˜¯é™¤æ•°ï¼Œåˆ™factor1æ˜¯é«˜åº¦ï¼Œfactor2æ˜¯ç­”æ¡ˆï¼ˆå®½åº¦ï¼‰
                // å¦‚æœfactor2æ˜¯é™¤æ•°ï¼Œåˆ™factor2æ˜¯å®½åº¦ï¼Œfactor1æ˜¯ç­”æ¡ˆï¼ˆé«˜åº¦ï¼‰
                let knownWidth, knownHeight;
                if (factor1 === divisor) {
                    knownHeight = divisor;
                    knownWidth = answer;
                } else {
                    knownWidth = divisor;
                    knownHeight = answer;
                }
                
                // ç»˜åˆ¶å®Œæ•´çš„é¢ç§¯åŒºåŸŸï¼ˆè“è‰²èƒŒæ™¯ï¼‰
                const areaGradient = ctx.createLinearGradient(
                    offsetX, offsetY, 
                    offsetX + knownWidth * cellSize, 
                    offsetY + knownHeight * cellSize
                );
                areaGradient.addColorStop(0, 'rgba(79, 172, 254, 0.4)');
                areaGradient.addColorStop(0.5, 'rgba(100, 181, 246, 0.4)');
                areaGradient.addColorStop(1, 'rgba(129, 212, 250, 0.4)');
                ctx.fillStyle = areaGradient;
                ctx.fillRect(offsetX, offsetY, knownWidth * cellSize, knownHeight * cellSize);
                
                // ç»˜åˆ¶é¢ç§¯åŒºåŸŸçš„è¾¹æ¡†
                ctx.strokeStyle = '#42a5f5';
                ctx.lineWidth = 2;
                ctx.strokeRect(offsetX, offsetY, knownWidth * cellSize, knownHeight * cellSize);
                
                // é«˜äº®æ˜¾ç¤ºå·²çŸ¥è¾¹ï¼ˆæ©™è‰²ç²—çº¿ï¼‰
                ctx.strokeStyle = '#ff9800'; // æ©™è‰²
                ctx.lineWidth = 5;
                ctx.setLineDash([]); // å®çº¿
                
                // æ ¹æ®å·²çŸ¥è¾¹æ˜¯å®½åº¦è¿˜æ˜¯é«˜åº¦æ¥ç»˜åˆ¶
                if (factor1 === divisor) {
                    // å·²çŸ¥è¾¹æ˜¯é«˜åº¦ï¼ˆå‚ç›´æ–¹å‘ï¼‰
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY);
                    ctx.lineTo(offsetX, offsetY + knownHeight * cellSize);
                    ctx.stroke();
                    
                    // åœ¨å·²çŸ¥è¾¹æ—è¾¹æ˜¾ç¤ºæ ‡ç­¾
                    ctx.fillStyle = '#ff9800';
                    ctx.font = `bold ${Math.max(16, Math.min(20, cellSize * 0.35))}px Arial`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`å·²çŸ¥è¾¹: ${divisor}`, offsetX - 80, offsetY + (knownHeight * cellSize) / 2);
                } else {
                    // å·²çŸ¥è¾¹æ˜¯å®½åº¦ï¼ˆæ°´å¹³æ–¹å‘ï¼‰
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY);
                    ctx.lineTo(offsetX + knownWidth * cellSize, offsetY);
                    ctx.stroke();
                    
                    // åœ¨å·²çŸ¥è¾¹æ—è¾¹æ˜¾ç¤ºæ ‡ç­¾
                    ctx.fillStyle = '#ff9800';
                    ctx.font = `bold ${Math.max(16, Math.min(20, cellSize * 0.35))}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`å·²çŸ¥è¾¹: ${divisor}`, offsetX + (knownWidth * cellSize) / 2, offsetY - 30);
                }
                
                // åœ¨é¢ç§¯åŒºåŸŸçš„æ¯ä¸ªå•å…ƒæ ¼ä¸­æ˜¾ç¤ºç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰
                ctx.fillStyle = '#1976d2';
                ctx.font = `bold ${Math.max(12, Math.min(18, cellSize * 0.3))}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let blockNumber = 1;
                for (let row = 0; row < knownHeight; row++) {
                    for (let col = 0; col < knownWidth; col++) {
                        const x = offsetX + (col + 0.5) * cellSize;
                        const y = offsetY + (row + 0.5) * cellSize;
                        ctx.fillText(blockNumber.toString(), x, y);
                        blockNumber++;
                    }
                }
                
                // åœ¨é¢ç§¯åŒºåŸŸä¸­å¿ƒæ˜¾ç¤ºé¢ç§¯å€¼ï¼ˆè¦†ç›–åœ¨ç¼–å·ä¸Šï¼Œä½¿ç”¨åŠé€æ˜èƒŒæ™¯ï¼‰
                const centerX = offsetX + (knownWidth * cellSize) / 2;
                const centerY = offsetY + (knownHeight * cellSize) / 2;
                
                // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(centerX - 50, centerY - 15, 100, 30);
                ctx.strokeStyle = '#1976d2';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - 50, centerY - 15, 100, 30);
                
                // æ˜¾ç¤ºé¢ç§¯å€¼
                ctx.fillStyle = '#1976d2';
                ctx.font = `bold ${Math.max(18, Math.min(28, cellSize * 0.4))}px Arial`;
                ctx.fillText(`é¢ç§¯: ${area}`, centerX, centerY);
            }
            
            // ç»˜åˆ¶é€‰ä¸­åŒºåŸŸ - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
            if (gameState.currentQuestion && gameState.selectedCells.size > 0) {
                const selectedArea = gameState.selectedCells.size;
                
                // æ£€æŸ¥æ˜¯å¦åŒ¹é…é¢˜ç›®
                let isCorrect = false;
                if (gameState.currentQuestion.type === 'multiply') {
                    isCorrect = selectedArea === gameState.currentQuestion.answer;
                } else {
                    // é™¤æ³•æ¨¡å¼ï¼šéªŒè¯é¢ç§¯å’Œè¾¹
                    const cells = Array.from(gameState.selectedCells).map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    });
                    
                    const minRow = Math.min(...cells.map(c => c.row));
                    const maxRow = Math.max(...cells.map(c => c.row));
                    const minCol = Math.min(...cells.map(c => c.col));
                    const maxCol = Math.max(...cells.map(c => c.col));
                    
                    const width = maxCol - minCol + 1;
                    const height = maxRow - minRow + 1;
                    
                    if (selectedArea === gameState.currentQuestion.area) {
                        if ((width === gameState.currentQuestion.divisor && height === gameState.currentQuestion.answer) ||
                            (height === gameState.currentQuestion.divisor && width === gameState.currentQuestion.answer)) {
                            isCorrect = true;
                        }
                    }
                }
                
                gameState.selectedCells.forEach(cellKey => {
                    const [row, col] = cellKey.split(',').map(Number);
                    const x = offsetX + col * cellSize;
                    const y = offsetY + row * cellSize;
                    
                    // ä½¿ç”¨æ›´é²œæ˜ã€æ›´ç¬¦åˆå„¿ç«¥åå¥½çš„é¢œè‰²
                    if (isCorrect) {
                        // æ­£ç¡®ç­”æ¡ˆï¼šä½¿ç”¨é²œè‰³çš„ç»¿è‰²æ¸å˜
                        const gradient = ctx.createLinearGradient(x, y, x + cellSize, y + cellSize);
                        gradient.addColorStop(0, 'rgba(76, 175, 80, 0.8)');
                        gradient.addColorStop(1, 'rgba(129, 199, 132, 0.8)');
                        ctx.fillStyle = gradient;
                        ctx.strokeStyle = '#4caf50';
                    } else {
                        // é”™è¯¯ç­”æ¡ˆï¼šä½¿ç”¨é²œè‰³çš„æ©™çº¢è‰²
                        ctx.fillStyle = 'rgba(255, 152, 0, 0.7)';
                        ctx.strokeStyle = '#ff9800';
                    }
                    ctx.fillRect(x, y, cellSize, cellSize);
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                });
            }
            
            // ç»˜åˆ¶æ‹–æ‹½åŒºåŸŸ - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
            if (gameState.isDragging && gameState.dragStart && gameState.dragEnd) {
                const startRow = Math.min(gameState.dragStart.row, gameState.dragEnd.row);
                const endRow = Math.max(gameState.dragStart.row, gameState.dragEnd.row);
                const startCol = Math.min(gameState.dragStart.col, gameState.dragEnd.col);
                const endCol = Math.max(gameState.dragStart.col, gameState.dragEnd.col);
                
                const x = offsetX + startCol * cellSize;
                const y = offsetY + startRow * cellSize;
                const width = (endCol - startCol + 1) * cellSize;
                const height = (endRow - startRow + 1) * cellSize;
                const dragWidth = endCol - startCol + 1;
                const dragHeight = endRow - startRow + 1;
                const area = dragWidth * dragHeight;
                
                // åœ¨é™¤æ³•æ¨¡å¼ä¸‹ï¼ŒéªŒè¯æ‹–æ‹½åŒºåŸŸæ˜¯å¦æ­£ç¡®
                let isCorrect = false;
                let areaCorrect = false;
                let edgeCorrect = false;
                
                if (gameState.currentQuestion && gameState.currentQuestion.type === 'divide') {
                    // æ£€æŸ¥é¢ç§¯æ˜¯å¦æ­£ç¡®
                    areaCorrect = area === gameState.currentQuestion.area;
                    // æ£€æŸ¥è¾¹æ˜¯å¦æ­£ç¡®ï¼ˆä¸€æ¡è¾¹æ˜¯é™¤æ•°ï¼Œå¦ä¸€æ¡è¾¹æ˜¯ç­”æ¡ˆï¼‰
                    edgeCorrect = (dragWidth === gameState.currentQuestion.divisor && dragHeight === gameState.currentQuestion.answer) ||
                                  (dragHeight === gameState.currentQuestion.divisor && dragWidth === gameState.currentQuestion.answer);
                    isCorrect = areaCorrect && edgeCorrect;
                }
                
                // æ ¹æ®éªŒè¯ç»“æœé€‰æ‹©é¢œè‰²
                if (gameState.currentQuestion && gameState.currentQuestion.type === 'divide') {
                    if (isCorrect) {
                        // å®Œå…¨æ­£ç¡®ï¼šç»¿è‰²
                        const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                        gradient.addColorStop(0, 'rgba(76, 175, 80, 0.6)');
                        gradient.addColorStop(1, 'rgba(129, 199, 132, 0.6)');
                        ctx.fillStyle = gradient;
                        ctx.strokeStyle = '#4caf50';
                    } else if (areaCorrect && !edgeCorrect) {
                        // é¢ç§¯æ­£ç¡®ä½†è¾¹ä¸å¯¹ï¼šé»„è‰²
                        ctx.fillStyle = 'rgba(255, 235, 59, 0.6)';
                        ctx.strokeStyle = '#ffc107';
                    } else {
                        // é¢ç§¯ä¸å¯¹ï¼šè“è‰²ï¼ˆæç¤ºç»§ç»­å°è¯•ï¼‰
                        const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                        gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                        gradient.addColorStop(0.5, 'rgba(100, 181, 246, 0.5)');
                        gradient.addColorStop(1, 'rgba(129, 212, 250, 0.5)');
                        ctx.fillStyle = gradient;
                        ctx.strokeStyle = '#42a5f5';
                    }
                } else {
                    // ä¹˜æ³•æ¨¡å¼ï¼šä½¿ç”¨è“è‰²æ¸å˜
                    const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                    gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
                    gradient.addColorStop(0.5, 'rgba(100, 181, 246, 0.5)');
                    gradient.addColorStop(1, 'rgba(129, 212, 250, 0.5)');
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#42a5f5';
                }
                
                ctx.fillRect(x, y, width, height);
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);
                
                // åœ¨æ‹–æ‹½åŒºåŸŸä¸­å¿ƒæ˜¾ç¤ºä¿¡æ¯
                if (gameState.showArea && area > 0) {
                    const centerX = x + width / 2;
                    const centerY = y + height / 2;
                    
                    ctx.font = `bold ${Math.max(16, Math.min(28, cellSize * 0.4))}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ç»˜åˆ¶èƒŒæ™¯æ¡†
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                    ctx.fillRect(centerX - 60, centerY - 25, 120, 50);
                    ctx.strokeStyle = ctx.strokeStyle;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(centerX - 60, centerY - 25, 120, 50);
                    
                    // æ˜¾ç¤ºä¿¡æ¯
                    if (gameState.currentQuestion && gameState.currentQuestion.type === 'divide') {
                        ctx.fillStyle = '#333';
                        ctx.fillText(`é¢ç§¯: ${area}`, centerX, centerY - 10);
                        ctx.fillText(`${dragWidth} Ã— ${dragHeight}`, centerX, centerY + 10);
                    } else {
                        ctx.fillStyle = '#1976d2';
                        ctx.fillText(`${area}`, centerX, centerY);
                    }
                }
            }
            
            // ç»˜åˆ¶æ‚¬åœé«˜äº® - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
            if (gameState.interactionMode === 'highlight' && gameState.hoveredCell) {
                const { row, col } = gameState.hoveredCell;
                
                // è®¡ç®—å¯èƒ½çš„çŸ©å½¢åŒºåŸŸ
                if (gameState.currentQuestion) {
                    const { factor1, factor2 } = gameState.currentQuestion;
                    
                    // æ˜¾ç¤ºå¤šä¸ªå¯èƒ½çš„çŸ©å½¢ç»„åˆ
                    for (let r = Math.max(0, row - factor1 + 1); r <= Math.min(gridSize - factor1, row); r++) {
                        for (let c = Math.max(0, col - factor2 + 1); c <= Math.min(gridSize - factor2, col); c++) {
                            if (r + factor1 <= gridSize && c + factor2 <= gridSize) {
                                const x = offsetX + c * cellSize;
                                const y = offsetY + r * cellSize;
                                // ä½¿ç”¨é²œè‰³çš„é»„è‰²æ¸å˜
                                const gradient = ctx.createLinearGradient(x, y, x + factor2 * cellSize, y + factor1 * cellSize);
                                gradient.addColorStop(0, 'rgba(255, 235, 59, 0.5)');
                                gradient.addColorStop(1, 'rgba(255, 193, 7, 0.5)');
                                ctx.fillStyle = gradient;
                                ctx.fillRect(x, y, factor2 * cellSize, factor1 * cellSize);
                                ctx.strokeStyle = '#ffc107';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(x, y, factor2 * cellSize, factor1 * cellSize);
                            }
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶æ•°å­—
            if (gameState.showNumbers) {
                const numberFontSize = Math.max(10, Math.min(20, cellSize * 0.25));
                ctx.font = `bold ${numberFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // åœ¨æ‹–æ‹½æ¨¡å¼ä¸‹ï¼Œåªæ˜¾ç¤ºæ‹–æ‹½åŒºåŸŸå†…çš„æ•°å­—
                if (gameState.interactionMode === 'drag') {
                    // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œæ˜¾ç¤ºæ‹–æ‹½åŒºåŸŸå†…çš„æ–¹å—ç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰
                    if (gameState.isDragging && gameState.dragStart && gameState.dragEnd) {
                        const startRow = Math.min(gameState.dragStart.row, gameState.dragEnd.row);
                        const endRow = Math.max(gameState.dragStart.row, gameState.dragEnd.row);
                        const startCol = Math.min(gameState.dragStart.col, gameState.dragEnd.col);
                        const endCol = Math.max(gameState.dragStart.col, gameState.dragEnd.col);
                        
                        // è®¡ç®—åŒºåŸŸå¤§å°
                        const width = endCol - startCol + 1;
                        const height = endRow - startRow + 1;
                        const totalArea = width * height;
                        
                        // æŒ‰ç…§ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹çš„é¡ºåºç¼–å·ï¼Œä»1å¼€å§‹
                        let blockNumber = 1;
                        for (let row = startRow; row <= endRow; row++) {
                            for (let col = startCol; col <= endCol; col++) {
                                if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
                                    const x = offsetX + (col + 0.5) * cellSize;
                                    const y = offsetY + (row + 0.5) * cellSize;
                                    ctx.fillStyle = '#1976d2'; // é²œè‰³çš„è“è‰²
                                    ctx.fillText(blockNumber.toString(), x, y);
                                    blockNumber++;
                                }
                            }
                        }
                    }
                    // å¦‚æœå·²é€‰ä¸­åŒºåŸŸï¼Œæ˜¾ç¤ºé€‰ä¸­åŒºåŸŸçš„æ–¹å—ç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰
                    else if (gameState.selectedCells.size > 0) {
                        // è·å–é€‰ä¸­åŒºåŸŸçš„èŒƒå›´
                        const cells = Array.from(gameState.selectedCells).map(key => {
                            const [r, c] = key.split(',').map(Number);
                            return { row: r, col: c };
                        });
                        
                        const minRow = Math.min(...cells.map(c => c.row));
                        const maxRow = Math.max(...cells.map(c => c.row));
                        const minCol = Math.min(...cells.map(c => c.col));
                        const maxCol = Math.max(...cells.map(c => c.col));
                        
                        // åˆ›å»ºä¸€ä¸ªé›†åˆæ¥å¿«é€ŸæŸ¥æ‰¾é€‰ä¸­çš„å•å…ƒæ ¼
                        const selectedSet = new Set(gameState.selectedCells);
                        
                        // æŒ‰ç…§ä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹çš„é¡ºåºç¼–å·ï¼Œä»1å¼€å§‹
                        let blockNumber = 1;
                        for (let row = minRow; row <= maxRow; row++) {
                            for (let col = minCol; col <= maxCol; col++) {
                                const cellKey = `${row},${col}`;
                                if (selectedSet.has(cellKey)) {
                                    const x = offsetX + (col + 0.5) * cellSize;
                                    const y = offsetY + (row + 0.5) * cellSize;
                                    ctx.fillStyle = '#fff';
                                    ctx.fillText(blockNumber.toString(), x, y);
                                    blockNumber++;
                                }
                            }
                        }
                    }
                    // å¦åˆ™ä¸æ˜¾ç¤ºä»»ä½•æ•°å­—
                } else {
                    // å…¶ä»–æ¨¡å¼ä¸‹ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ•°å­—
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            const number = row * gridSize + col + 1;
                            const x = offsetX + (col + 0.5) * cellSize;
                            const y = offsetY + (row + 0.5) * cellSize;
                            
                            // å¦‚æœè¢«é€‰ä¸­ï¼Œæ”¹å˜é¢œè‰²
                            const cellKey = `${row},${col}`;
                            if (gameState.selectedCells.has(cellKey)) {
                                ctx.fillStyle = '#fff';
                            } else {
                                ctx.fillStyle = '#ff4081'; // é²œè‰³çš„ç²‰çº¢è‰²ï¼Œæ›´ç¬¦åˆå„¿ç«¥åå¥½
                            }
                            
                            ctx.fillText(number.toString(), x, y);
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶é¢ç§¯ä¿¡æ¯
            if (gameState.showArea && gameState.currentQuestion && gameState.selectedCells.size > 0) {
                const area = gameState.selectedCells.size;
                
                ctx.font = `bold ${Math.max(14, Math.min(24, cellSize * 0.35))}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // åœ¨é€‰ä¸­åŒºåŸŸä¸­å¿ƒæ˜¾ç¤ºé¢ç§¯
                if (gameState.selectedCells.size > 0) {
                    const cells = Array.from(gameState.selectedCells).map(key => {
                        const [r, c] = key.split(',').map(Number);
                        return { row: r, col: c };
                    });
                    
                    const minRow = Math.min(...cells.map(c => c.row));
                    const maxRow = Math.max(...cells.map(c => c.row));
                    const minCol = Math.min(...cells.map(c => c.col));
                    const maxCol = Math.max(...cells.map(c => c.col));
                    
                    const centerX = offsetX + (minCol + maxCol + 1) * cellSize / 2;
                    const centerY = offsetY + (minRow + maxRow + 1) * cellSize / 2;
                    
                    // ç»˜åˆ¶èƒŒæ™¯æ¡† - ä½¿ç”¨æ›´é²œæ˜çš„é¢œè‰²
                    const isCorrect = area === gameState.currentQuestion.answer;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                    ctx.fillRect(centerX - 45, centerY - 18, 90, 36);
                    ctx.strokeStyle = isCorrect ? '#4caf50' : '#ff9800';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(centerX - 45, centerY - 18, 90, 36);
                    
                    ctx.fillStyle = isCorrect ? '#2e7d32' : '#e65100'; // æ›´é²œæ˜çš„é¢œè‰²
                    ctx.fillText(`${area}`, centerX, centerY);
                }
            }
        }

        // è®¾ç½®äº¤äº’æ¨¡å¼
        // è®¾ç½®æ¸¸æˆæ¨¡å¼ï¼ˆä¹˜æ³•/é™¤æ³•ï¼‰
        function setGameMode(mode) {
            gameState.gameMode = mode;
            gameState.selectedCells.clear();
            gameState.isDragging = false;
            gameState.dragStart = null;
            gameState.dragEnd = null;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('multiplyMode').classList.toggle('active', mode === 'multiply');
            document.getElementById('divideMode').classList.toggle('active', mode === 'divide');
            
            // é‡æ–°ç”Ÿæˆé¢˜ç›®
            currentLevelQuestions = generateLevelQuestions();
            usedQuestions = [];
            currentLevelQuestionCount = 0;
            
            // æ›´æ–°å…³å¡æè¿°
            updateLevelInfo();
            
            // è·å–ä¸‹ä¸€é¢˜
            nextQuestion();
        }

        function setInteractionMode(mode) {
            gameState.interactionMode = mode;
            gameState.selectedCells.clear();
            gameState.isDragging = false;
            gameState.dragStart = null;
            gameState.dragEnd = null;
            
            document.getElementById('clickMode').classList.toggle('active', mode === 'click');
            document.getElementById('dragMode').classList.toggle('active', mode === 'drag');
            
            const modeTexts = {
                click: 'ç‚¹å‡»é€‰æ‹©',
                drag: 'æ‹–æ‹½ç»˜åˆ¶'
            };
            document.getElementById('modeIndicator').textContent = `å½“å‰æ¨¡å¼ï¼š${modeTexts[mode]}`;
            
            draw();
        }

        // åˆ‡æ¢æ˜¾ç¤ºé€‰é¡¹
        function toggleOption(option) {
            const btn = document.getElementById(`show${option.charAt(0).toUpperCase() + option.slice(1)}`);
            btn.classList.toggle('active');
            
            if (option === 'grid') gameState.showGrid = !gameState.showGrid;
            if (option === 'numbers') gameState.showNumbers = !gameState.showNumbers;
            if (option === 'area') gameState.showArea = !gameState.showArea;
            
            draw();
        }

        // æ˜¾ç¤ºåé¦ˆ
        function showFeedback(isCorrect) {
            const feedback = document.getElementById('feedback');
            
            // ä½¿ç”¨æ›´æœ‰è¶£ã€æ›´ç¬¦åˆå„¿ç«¥åå¥½çš„æç¤ºæ–‡æœ¬
            const correctMessages = [
                'ğŸ‰ å¤ªæ£’äº†ï¼',
                'ğŸŒŸ ä½ çœŸèªæ˜ï¼',
                'â­ åšå¾—å¥½ï¼',
                'ğŸ’« å®Œç¾ï¼',
                'ğŸŠ å¤ªå‰å®³äº†ï¼',
                'ğŸ† çœŸæ£’ï¼',
                'âœ¨ å¥½æ ·çš„ï¼',
                'ğŸˆ å¤ªå¯¹äº†ï¼'
            ];
            
            const wrongMessages = [
                'ğŸ˜Š å†è¯•è¯•å§ï¼',
                'ğŸ’ª åŠ æ²¹ï¼',
                'ğŸ¤” å†æƒ³æƒ³ï¼',
                'ğŸ’¡ ç»§ç»­åŠªåŠ›ï¼'
            ];
            
            if (isCorrect) {
                const randomMessage = correctMessages[Math.floor(Math.random() * correctMessages.length)];
                feedback.textContent = randomMessage;
                feedback.className = `feedback correct show`;
            } else {
                const randomMessage = wrongMessages[Math.floor(Math.random() * wrongMessages.length)];
                feedback.textContent = randomMessage;
                feedback.className = `feedback wrong show`;
            }
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 2000); // å»¶é•¿æ˜¾ç¤ºæ—¶é—´ï¼Œè®©å„¿ç«¥æœ‰è¶³å¤Ÿæ—¶é—´çœ‹åˆ°
        }

        // æ›´æ–°ç»Ÿè®¡
        function updateStats() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('correctCount').textContent = gameState.correctCount;
            document.getElementById('level').textContent = gameState.level;
        }

        // æ›´æ–°å…³å¡ä¿¡æ¯
        function updateLevelInfo() {
            const level = levels[gameState.level - 1];
            document.getElementById('levelTitle').textContent = level.title;
            
            // æ ¹æ®æ¸¸æˆæ¨¡å¼æ›´æ–°æè¿°
            if (gameState.gameMode === 'multiply') {
                document.getElementById('levelDescription').textContent = level.description;
            } else {
                // é™¤æ³•æ¨¡å¼æè¿°
                const divideDescriptions = {
                    1: 'å­¦ä¹ 1-5çš„é™¤æ³•ï¼Œé€šè¿‡é¢ç§¯æ¨¡å‹ç†è§£é™¤æ³•ä¸ä¹˜æ³•çš„å…³ç³»ã€‚',
                    2: 'æŒæ¡6-8çš„é™¤æ³•ï¼ŒåŠ æ·±å¯¹é¢ç§¯æ¨¡å‹çš„ç†è§£ã€‚',
                    3: 'æŒ‘æˆ˜9-12çš„é™¤æ³•ï¼Œç†Ÿç»ƒæŒæ¡é¢ç§¯è®¡ç®—æ–¹æ³•ã€‚',
                    4: 'æ··åˆç»ƒä¹ æ‰€æœ‰é™¤æ³•ï¼Œå·©å›ºå­¦ä¹ æˆæœã€‚'
                };
                document.getElementById('levelDescription').textContent = divideDescriptions[gameState.level] || level.description;
            }
        }

        // æ›´æ–°å…³å¡è¿›åº¦
        function updateLevelProgress() {
            const level = levels[gameState.level - 1];
            const progress = (currentLevelQuestionCount / level.questionsPerLevel) * 100;
            gameState.levelProgress = Math.min(100, progress);
            document.getElementById('levelProgress').style.width = `${gameState.levelProgress}%`;
        }

        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿæ‰€æœ‰è¿›åº¦å°†ä¸¢å¤±ã€‚')) {
                gameState.score = 0;
                gameState.correctCount = 0;
                gameState.wrongCount = 0;
                gameState.level = 1;
                gameState.levelProgress = 0;
                currentLevelQuestions = generateLevelQuestions();
                usedQuestions = [];
                currentLevelQuestionCount = 0; // é‡ç½®å½“å‰å…³å¡é¢˜ç›®è®¡æ•°
                updateLevelInfo();
                updateStats();
                nextQuestion();
            }
        }

        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            initCanvas();
            currentLevelQuestions = generateLevelQuestions();
            updateLevelInfo();
            updateStats();
            nextQuestion();
        });
    </script>
</body>
</html>